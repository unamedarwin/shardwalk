<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Shardwalk: Isometric Chronicles</title>
  <style>
    html, body { margin: 0; height: 100%; background: #0e0e10; overflow: hidden; }
    #game { width: 100%; height: 100%; }
    canvas { display: block; touch-action: none; }

    #hud {
      position: fixed; top: 10px; left: 10px; right: 10px;
      display: flex; gap: 8px; align-items: center; flex-wrap: wrap;
      font: 13px system-ui, -apple-system, Segoe UI, Roboto, Arial;
      color: #fff; z-index: 10; user-select: none;
    }
    .chip {
      background: rgba(0,0,0,.35);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 10px; padding: 6px 10px;
      display: inline-flex; gap: 6px; align-items: center;
    }
    button, label.btn {
      background: rgba(0,0,0,.35);
      border: 1px solid rgba(255,255,255,.18);
      border-radius: 10px;
      color: #fff; padding: 6px 10px; cursor: pointer;
      display: inline-flex; gap: 8px; align-items: center;
    }
    button:active, label.btn:active { transform: translateY(1px); }
    input[type="file"] { display: none; }

    /* Flags */
    .flag { width: 20px; height: 14px; display: inline-block; border-radius: 3px; object-fit: cover; }
    .langbtn { padding: 6px 8px; }
    .langbtn[aria-pressed="true"] { outline: 2px solid rgba(255,255,255,.35); }

    #actions {
      position: fixed; right: 14px; bottom: 14px; z-index: 10;
      display: flex; gap: 8px;
      font: 14px system-ui, -apple-system, Segoe UI, Roboto, Arial;
    }
    #actions button { padding: 10px 12px; }

    #pad {
      position: fixed; left: 14px; bottom: 14px; z-index: 10;
      display: grid; grid-template-columns: 44px 44px 44px;
      grid-template-rows: 44px 44px 44px;
      gap: 6px; user-select: none;
    }
    #pad button { width: 44px; height: 44px; padding: 0; font-size: 18px; }
    #pad .empty { visibility: hidden; }

    #modal {
      position: fixed; inset: 0; background: rgba(0,0,0,.62);
      display: none; align-items: center; justify-content: center;
      z-index: 30; padding: 18px;
    }
    #modal .box {
      width: min(860px, 100%);
      background: #141416;
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 14px;
      padding: 14px;
      color: #fff;
      font: 14px system-ui, -apple-system, Segoe UI, Roboto, Arial;
      max-height: 82vh; overflow: auto;
    }
    #modal .row { display: flex; justify-content: space-between; gap: 10px; align-items: center; }
    #modal h2 { margin: 0; font-size: 16px; }
    #modal p, #modal li { opacity: .92; line-height: 1.35; }
    .muted { opacity: .75; }
    .grid2 { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .card {
      background: rgba(255,255,255,.04);
      border: 1px solid rgba(255,255,255,.08);
      border-radius: 12px; padding: 10px;
    }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .kbd { border: 1px solid rgba(255,255,255,.18); border-bottom-width: 2px; padding: 0 6px; border-radius: 8px; background: rgba(0,0,0,.25); }

    #login {
      position: fixed; inset: 0; display: flex; align-items: center; justify-content: center;
      background: radial-gradient(1200px 600px at 50% 30%, rgba(80,120,255,.15), rgba(0,0,0,.85));
      z-index: 50; padding: 18px;
    }
    #login .panel {
      width: min(920px, 100%);
      background: rgba(16,16,18,.92);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 16px;
      padding: 14px;
      color: #fff;
      font: 14px system-ui, -apple-system, Segoe UI, Roboto, Arial;
    }
    #login h1 { margin: 0 0 6px 0; font-size: 18px; }
    #login .panel p { margin: 6px 0; opacity: .9; }
    #login .fields { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 10px; }
    #login input, #login select {
      width: 100%; padding: 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.35);
      color: #fff;
      outline: none;
    }
    #login .actions { display: flex; gap: 8px; flex-wrap: wrap; margin-top: 12px; align-items: center; }
    #langPickerLogin { display: flex; gap: 6px; flex-wrap: wrap; margin: 8px 0 6px; }
    #toast {
      position: fixed; left: 50%; bottom: 92px; transform: translateX(-50%);
      background: rgba(0,0,0,.55);
      border: 1px solid rgba(255,255,255,.14);
      color: #fff; padding: 8px 10px; border-radius: 12px;
      font: 13px system-ui, -apple-system, Segoe UI, Roboto, Arial;
      z-index: 40; display: none;
      max-width: min(720px, 92vw);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
  </style>
</head>
<body>

  <div id="login">
    <div class="panel">
      <h1>Shardwalk: Isometric Chronicles</h1>

      <div id="langPickerLogin" aria-label="Language picker"></div>

      <p class="muted" data-i18n="login.tagline"></p>
      <p>
        <span data-i18n="hud.room"></span>: <b id="roomLabel"></b>
        <span class="muted"> <span data-i18n="login.shareHint"></span> <span class="mono">?room=...</span></span>
      </p>

      <div class="fields">
        <div>
          <label class="muted" data-i18n="login.nameLabel"></label>
          <input id="name" maxlength="18" />
        </div>
        <div>
          <label class="muted" data-i18n="login.passLabel"></label>
          <input id="pass" type="password" />
        </div>
        <div>
          <label class="muted" data-i18n="login.lifestyleLabel"></label>
          <select id="life"></select>
        </div>
        <div>
          <label class="muted" data-i18n="login.optionsLabel"></label>
          <select id="remember"></select>
        </div>
      </div>

      <div class="actions">
        <button id="start" data-i18n="login.enterWorld"></button>
        <button id="copyLink" data-i18n="login.copyLink"></button>
        <span class="muted" data-i18n="login.controls"></span>
      </div>

      <p class="muted" style="margin-top:10px" data-i18n="login.ledgerNote"></p>
    </div>
  </div>

  <div id="hud" style="display:none">
    <button id="btnLang" class="langbtn" title="Language" aria-label="Language">
      <img id="langIcon" class="flag" alt="" />
    </button>

    <div class="chip"><span data-i18n="hud.room"></span>: <b id="room"></b></div>
    <div class="chip"><span data-i18n="hud.peers"></span>: <b id="peers">0</b></div>
    <div class="chip"><span data-i18n="hud.you"></span>: <b id="me">‚Ä¶</b></div>
    <div class="chip">‚ô• <b id="hp">100</b></div>
    <div class="chip">‚ö° <b id="stam">100</b></div>
    <div class="chip">üçñ <b id="hunger">0</b></div>
    <div class="chip"><span data-i18n="hud.weight"></span> <b id="wt">0</b>/<b id="cap">0</b></div>

    <div class="chip">
      ü™µ <b id="wood">0</b>
      ‚õè <b id="stone">0</b>
      ‚õì <b id="ore">0</b>
      üßµ <b id="fiber">0</b>
      üêæ <b id="hide">0</b>
      ‚úß <b id="shard">0</b>
      üçì <b id="berry">0</b>
    </div>

    <button id="btnQuests" data-i18n="btn.quests"></button>
    <button id="btnSkills" data-i18n="btn.skills"></button>
    <button id="btnCraft" data-i18n="btn.craft"></button>
    <button id="btnWorld" data-i18n="btn.world"></button>
    <button id="btnCredits" data-i18n="btn.credits"></button>
    <button id="btnExport" data-i18n="btn.export"></button>
    <label class="btn"><span data-i18n="btn.import"></span> <input id="import" type="file" accept="application/json" /></label>
  </div>

  <div id="pad" style="display:none" aria-label="controls">
    <div class="empty"></div><button id="btnUp">‚ñ≤</button><div class="empty"></div>
    <button id="btnLeft">‚óÄ</button><div class="empty"></div><button id="btnRight">‚ñ∂</button>
    <div class="empty"></div><button id="btnDown">‚ñº</button><div class="empty"></div>
  </div>

  <div id="actions" style="display:none">
    <button id="btnAction"></button>
    <button id="btnAttack"></button>
  </div>

  <div id="toast"></div>
  <div id="game"></div>

  <div id="modal">
    <div class="box">
      <div class="row">
        <h2 id="modalTitle">‚Äî</h2>
        <button id="closeModal" data-i18n="ui.close"></button>
      </div>
      <div id="modalBody" style="margin-top:10px"></div>
    </div>
  </div>

  <script type="module">
    import * as Phaser from "https://cdn.jsdelivr.net/npm/phaser@3.90.0/dist/phaser.esm.js";
    import nacl from "https://esm.run/tweetnacl";
    import { sha256 } from "https://esm.run/@noble/hashes/sha256";
    import { bytesToHex } from "https://esm.run/@noble/hashes/utils";
    import { joinRoom } from "https://esm.run/trystero/torrent";
    import { selfId } from "https://esm.run/trystero";

    // ============================================================
    // i18n (6 languages: EN, ZH, HI, ES, FR, CA)
    // ============================================================
    const GAME_TITLE = "Shardwalk: Isometric Chronicles";

    const FLAG = {
      en: "https://cdn.jsdelivr.net/gh/twitter/twemoji@14.0.2/assets/svg/1f1fa-1f1f8.svg", // US
      zh: "https://cdn.jsdelivr.net/gh/twitter/twemoji@14.0.2/assets/svg/1f1e8-1f1f3.svg", // CN
      hi: "https://cdn.jsdelivr.net/gh/twitter/twemoji@14.0.2/assets/svg/1f1ee-1f1f3.svg", // IN
      es: "https://cdn.jsdelivr.net/gh/twitter/twemoji@14.0.2/assets/svg/1f1ea-1f1f8.svg", // ES
      fr: "https://cdn.jsdelivr.net/gh/twitter/twemoji@14.0.2/assets/svg/1f1eb-1f1f7.svg", // FR
      ca: "https://upload.wikimedia.org/wikipedia/commons/c/ce/Flag_of_Catalonia.svg"        // Senyera
    };

    const I18N = {
      en: {
        ui: { close: "Close", language: "Language" },
        hud: { room: "Room", peers: "Peers", you: "You", weight: "Wt" },
        btn: { quests: "Quests", skills: "Skills", craft: "Craft", world: "World", credits: "Credits", export: "Export", import: "Import", action: "Action (E)", attack: "Attack (‚ê£)" },
        login: {
          tagline: "Procedural isometric world + survival + P2P (WebRTC) + signed append-only ledger.",
          shareHint: "(share link with)",
          nameLabel: "Character name",
          passLabel: "Passphrase (stays on device)",
          lifestyleLabel: "Lifestyle",
          optionsLabel: "Options",
          enterWorld: "Enter the world",
          copyLink: "Copy link",
          controls: "Controls: WASD/Arrows, E action, Space attack, Enter chat",
          ledgerNote: "The shared ledger is readable by everyone, but nobody can sign as you‚Äîso they can't modify what you own."
        },
        sel: {
          rememberNo: "Don't remember passphrase",
          rememberYes: "Remember passphrase (NOT recommended)"
        },
        life: {
          Explorer: "Explorer (exploration + endurance)",
          Crafter: "Crafter (crafting + building)",
          Hunter: "Hunter (combat + loot)",
          Scholar: "Scholar (runes + lore)",
          Merchant: "Merchant (social + utility)",
          Mystic: "Mystic (rituals + night)"
        },
        modal: {
          language: "Language",
          quests: "Quests (progress)",
          skills: "Skills + Lifestyle",
          world: "Shared world (ledger)",
          credits: "Credits & licenses",
          craft: "Craft (tools, gear, building)",
          sign: "Signpost",
          author: "Author",
          removeMine: "Remove (only you)",
          summary: "Summary",
          ranking: "Ranking (shrines)",
          tip: "Tip: shared objects are immutable; only the owner can remove them (by signing).",
          recipesBasic: "Recipes (basic)",
          recipesAdv: "Advanced (requires Workbench nearby)",
          materials: "Materials",
          currentEquip: "Current equipment",
          position: "Position"
        },
        common: { progress: "Progress", completed: "completed", reward: "Reward" },
        names: {
          biomes: { Water:"Water", Swamp:"Swamp", Forest:"Forest", Grass:"Grassland", Stone:"Stone", Sand:"Sand", Mount:"Mountains", Snow:"Snow" },
          monsters: { Slime:"Slime", Wolf:"Wolf", Bandit:"Bandit", Wisp:"Wisp" },
          items: {
            Axe:"Axe", Pickaxe:"Pickaxe", Campfire:"Campfire", Workbench:"Workbench", Signpost:"Signpost",
            Spear:"Spear", Sword:"Sword", Cloak:"Cloak", Leather:"Leather armor", Lantern:"Lantern"
          },
          decor: { Tree:"Tree", Rock:"Rock", Bush:"Bush", Ore:"Ore vein", Herb:"Herbs", Bones:"Bones", Ruins:"Ruins", Shrine:"Shrine" }
        },
        toast: {
          linkCopied: "Link copied",
          p2pOffline: "P2P unavailable (offline + export/import)",
          importOk: "Import OK",
          importFail: "Import failed",
          chooseName: "Choose a name",
          choosePass: "Enter a passphrase",
          welcome: "Welcome to Shardwalk!",
          deepWater: "Deep water: you can't pass",
          newBiome: "New biome: {biome}",
          spawned: "Spawned: {monster}",
          mining: "Mining PoW‚Ä¶ tap Action to cancel",
          miningCancelled: "Mining cancelled",
          shrineClaimed: "Shrine claimed!",
          rest: "You rest by the campfire",
          benchNeeded: "You need a Workbench nearby",
          ruinsAlready: "You already searched these ruins",
          ruinsLoot: "Ruins loot: {loot}",
          needPickaxe: "You need a Pickaxe to mine ore",
          nothing: "Nothing to do here",
          noEnemies: "No enemies nearby",
          hit: "Hit! -{dmg}",
          enemyDefeated: "Enemy defeated! Loot: {loot}",
          youFell: "You fell‚Ä¶ respawning at the origin",
          notEnough: "Not enough materials",
          equipped: "Equipped: {item}",
          placedShared: "Placed (shared): {item}",
          ateBerry: "You eat a berry",
          msgSent: "Message sent"
        },
        prompt: {
          signText: "Sign text (max 160):",
          signDefault: "The road is long‚Äîlet the shard guide you.",
          chat: "Say (P2P, ephemeral):",
          chatDefault: "Hello!"
        },
        quest: {
          cartoTitle: "Cartographer",
          cartoDesc: "Discover {n} new biomes (cumulative).",
          gatherTitle: "Survival",
          gatherDesc: "Gather {n} resources (trees/rocks/ore/herbs/ruins).",
          valorTitle: "Trial of Valor",
          valorDesc: "Defeat {n} enemies.",
          shrineTitle: "Ancient Rune",
          shrineDesc: "Claim {n} shrine (PoW).",
          benchTitle: "Carpentry",
          benchDesc: "Build a Workbench (shared).",
          toolTitle: "Tools",
          toolDesc: "Craft a tool (Axe or Pickaxe)."
        }
      },

      es: {
        ui: { close: "Cerrar", language: "Idioma" },
        hud: { room: "Sala", peers: "Jugadores", you: "T√∫", weight: "Peso" },
        btn: { quests: "Misiones", skills: "Habilidades", craft: "Crafteo", world: "Mundo", credits: "Cr√©ditos", export: "Exportar", import: "Importar", action: "Acci√≥n (E)", attack: "Atacar (‚ê£)" },
        login: {
          tagline: "Mundo isom√©trico procedural + supervivencia + P2P (WebRTC) + ledger firmado (append-only).",
          shareHint: "(comparte el enlace con)",
          nameLabel: "Nombre del personaje",
          passLabel: "Frase clave (se queda en el dispositivo)",
          lifestyleLabel: "Estilo de vida",
          optionsLabel: "Opciones",
          enterWorld: "Entrar al mundo",
          copyLink: "Copiar enlace",
          controls: "Controles: WASD/Flechas, E acci√≥n, Espacio atacar, Enter chat",
          ledgerNote: "El ledger compartido es legible por todos, pero nadie puede firmar como t√∫‚Äîno pueden modificar lo que es tuyo."
        },
        sel: { rememberNo: "No recordar frase", rememberYes: "Recordar frase (NO recomendado)" },
        life: {
          Explorer: "Explorador (exploraci√≥n + resistencia)",
          Crafter: "Artesano (crafteo + construcci√≥n)",
          Hunter: "Cazador (combate + bot√≠n)",
          Scholar: "Erudito (runas + saber)",
          Merchant: "Mercader (social + utilidad)",
          Mystic: "M√≠stico (rituales + noche)"
        },
        modal: {
          language: "Idioma", quests: "Misiones (progreso)", skills: "Habilidades + Estilo", world: "Mundo compartido (ledger)",
          credits: "Cr√©ditos y licencias", craft: "Crafteo (herramientas, equipo, construcci√≥n)", sign: "Cartel",
          author: "Autor", removeMine: "Eliminar (solo t√∫)", summary: "Resumen", ranking: "Ranking (santuarios)",
          tip: "Consejo: los objetos compartidos son inmutables; solo el propietario puede retirarlos (firmando).",
          recipesBasic: "Recetas (b√°sicas)", recipesAdv: "Avanzado (requiere Banco de trabajo cerca)",
          materials: "Materiales", currentEquip: "Equipo actual", position: "Posici√≥n"
        },
        common: { progress: "Progreso", completed: "completada", reward: "Recompensa" },
        names: {
          biomes: { Water:"Agua", Swamp:"Pantano", Forest:"Bosque", Grass:"Pradera", Stone:"Piedra", Sand:"Arena", Mount:"Monta√±as", Snow:"Nieve" },
          monsters: { Slime:"Baba", Wolf:"Lobo", Bandit:"Bandido", Wisp:"Fuego fatuo" },
          items: {
            Axe:"Hacha", Pickaxe:"Pico", Campfire:"Hoguera", Workbench:"Banco de trabajo", Signpost:"Cartel",
            Spear:"Lanza", Sword:"Espada", Cloak:"Capa", Leather:"Armadura de cuero", Lantern:"Linterna"
          },
          decor: { Tree:"√Årbol", Rock:"Roca", Bush:"Arbusto", Ore:"Veta", Herb:"Hierbas", Bones:"Huesos", Ruins:"Ruinas", Shrine:"Santuario" }
        },
        toast: {
          linkCopied: "Enlace copiado",
          p2pOffline: "P2P no disponible (offline + export/import)",
          importOk: "Importaci√≥n OK",
          importFail: "Fallo al importar",
          chooseName: "Elige un nombre",
          choosePass: "Escribe una frase clave",
          welcome: "¬°Bienvenido/a a Shardwalk!",
          deepWater: "Agua profunda: no puedes pasar",
          newBiome: "Nuevo bioma: {biome}",
          spawned: "Aparece: {monster}",
          mining: "Minando PoW‚Ä¶ toca Acci√≥n para cancelar",
          miningCancelled: "Miner√≠a cancelada",
          shrineClaimed: "¬°Santuario reclamado!",
          rest: "Descansas junto a la hoguera",
          benchNeeded: "Necesitas un Banco de trabajo cerca",
          ruinsAlready: "Ya registraste estas ruinas",
          ruinsLoot: "Bot√≠n de ruinas: {loot}",
          needPickaxe: "Necesitas un Pico para minar",
          nothing: "Nada que hacer aqu√≠",
          noEnemies: "No hay enemigos cerca",
          hit: "¬°Golpe! -{dmg}",
          enemyDefeated: "Enemigo derrotado. Bot√≠n: {loot}",
          youFell: "Has ca√≠do‚Ä¶ reapareces en el origen",
          notEnough: "No tienes materiales",
          equipped: "Equipado: {item}",
          placedShared: "Colocado (compartido): {item}",
          ateBerry: "Comes una baya",
          msgSent: "Mensaje enviado"
        },
        prompt: {
          signText: "Texto del cartel (m√°x 160):",
          signDefault: "El camino es largo; la esquirla gu√≠a.",
          chat: "Decir (P2P, ef√≠mero):",
          chatDefault: "¬°Hola!"
        },
        quest: {
          cartoTitle: "Cart√≥grafo/a",
          cartoDesc: "Descubre {n} biomas nuevos (acumulado).",
          gatherTitle: "Supervivencia",
          gatherDesc: "Recolecta {n} recursos (√°rbol/roca/veta/hierbas/ruinas).",
          valorTitle: "Prueba de valor",
          valorDesc: "Derrota {n} enemigos.",
          shrineTitle: "Runa ancestral",
          shrineDesc: "Reclama {n} santuario (PoW).",
          benchTitle: "Carpinter√≠a",
          benchDesc: "Construye un Banco de trabajo (compartido).",
          toolTitle: "Herramientas",
          toolDesc: "Craftea una herramienta (Hacha o Pico)."
        }
      },

      fr: {
        ui: { close: "Fermer", language: "Langue" },
        hud: { room: "Salle", peers: "Joueurs", you: "Vous", weight: "Poids" },
        btn: { quests: "Qu√™tes", skills: "Comp√©tences", craft: "Craft", world: "Monde", credits: "Cr√©dits", export: "Exporter", import: "Importer", action: "Action (E)", attack: "Attaquer (‚ê£)" },
        login: {
          tagline: "Monde isom√©trique proc√©dural + survie + P2P (WebRTC) + registre sign√© (append-only).",
          shareHint: "(partagez le lien avec)",
          nameLabel: "Nom du personnage",
          passLabel: "Phrase secr√®te (reste sur l'appareil)",
          lifestyleLabel: "Style de vie",
          optionsLabel: "Options",
          enterWorld: "Entrer dans le monde",
          copyLink: "Copier le lien",
          controls: "Contr√¥les : WASD/Fl√®ches, E action, Espace attaquer, Entr√©e chat",
          ledgerNote: "Le registre partag√© est lisible par tous, mais personne ne peut signer √† votre place‚Äîils ne peuvent pas modifier ce qui vous appartient."
        },
        sel: { rememberNo: "Ne pas m√©moriser", rememberYes: "M√©moriser (NON recommand√©)" },
        life: {
          Explorer: "Explorateur (exploration + endurance)",
          Crafter: "Artisan (craft + construction)",
          Hunter: "Chasseur (combat + butin)",
          Scholar: "Savant (runes + savoir)",
          Merchant: "Marchand (social + utilit√©)",
          Mystic: "Mystique (rituels + nuit)"
        },
        modal: {
          language: "Langue", quests: "Qu√™tes (progression)", skills: "Comp√©tences + Style", world: "Monde partag√© (registre)",
          credits: "Cr√©dits et licences", craft: "Craft (outils, √©quipement, construction)", sign: "Panneau",
          author: "Auteur", removeMine: "Retirer (vous seul)", summary: "R√©sum√©", ranking: "Classement (sanctuaires)",
          tip: "Astuce : les objets partag√©s sont immuables ; seul le propri√©taire peut les retirer (en signant).",
          recipesBasic: "Recettes (de base)", recipesAdv: "Avanc√© (√©tabli requis √† proximit√©)",
          materials: "Mat√©riaux", currentEquip: "√âquipement actuel", position: "Position"
        },
        common: { progress: "Progression", completed: "termin√©e", reward: "R√©compense" },
        names: {
          biomes: { Water:"Eau", Swamp:"Marais", Forest:"For√™t", Grass:"Prairie", Stone:"Pierre", Sand:"Sable", Mount:"Montagnes", Snow:"Neige" },
          monsters: { Slime:"Gluant", Wolf:"Loup", Bandit:"Bandit", Wisp:"Feu follet" },
          items: {
            Axe:"Hache", Pickaxe:"Pioche", Campfire:"Feu de camp", Workbench:"√âtabli", Signpost:"Panneau",
            Spear:"Lance", Sword:"√âp√©e", Cloak:"Cape", Leather:"Armure de cuir", Lantern:"Lanterne"
          },
          decor: { Tree:"Arbre", Rock:"Rocher", Bush:"Buisson", Ore:"Filon", Herb:"Herbes", Bones:"Os", Ruins:"Ruines", Shrine:"Sanctuaire" }
        },
        toast: {
          linkCopied: "Lien copi√©",
          p2pOffline: "P2P indisponible (hors-ligne + export/import)",
          importOk: "Import OK",
          importFail: "√âchec de l'import",
          chooseName: "Choisissez un nom",
          choosePass: "Entrez une phrase secr√®te",
          welcome: "Bienvenue sur Shardwalk !",
          deepWater: "Eau profonde : impossible de passer",
          newBiome: "Nouveau biome : {biome}",
          spawned: "Apparition : {monster}",
          mining: "Minage PoW‚Ä¶ touchez Action pour annuler",
          miningCancelled: "Minage annul√©",
          shrineClaimed: "Sanctuaire revendiqu√© !",
          rest: "Vous vous reposez au feu de camp",
          benchNeeded: "Un √©tabli est requis √† proximit√©",
          ruinsAlready: "Vous avez d√©j√† fouill√© ces ruines",
          ruinsLoot: "Butin des ruines : {loot}",
          needPickaxe: "Il faut une pioche pour miner",
          nothing: "Rien √† faire ici",
          noEnemies: "Aucun ennemi proche",
          hit: "Coup ! -{dmg}",
          enemyDefeated: "Ennemi vaincu. Butin : {loot}",
          youFell: "Vous √™tes tomb√©‚Ä¶ retour √† l'origine",
          notEnough: "Mat√©riaux insuffisants",
          equipped: "√âquip√© : {item}",
          placedShared: "Plac√©e (partag√©e) : {item}",
          ateBerry: "Vous mangez une baie",
          msgSent: "Message envoy√©"
        },
        prompt: {
          signText: "Texte du panneau (max 160) :",
          signDefault: "La route est longue ‚Äî que l'√©clat vous guide.",
          chat: "Dire (P2P, √©ph√©m√®re) :",
          chatDefault: "Salut !"
        },
        quest: {
          cartoTitle: "Cartographe",
          cartoDesc: "D√©couvrez {n} nouveaux biomes (cumul√©).",
          gatherTitle: "Survie",
          gatherDesc: "R√©coltez {n} ressources (arbre/rocher/filon/herbes/ruines).",
          valorTitle: "√âpreuve de bravoure",
          valorDesc: "Vainquez {n} ennemis.",
          shrineTitle: "Rune ancestrale",
          shrineDesc: "Revendiquez {n} sanctuaire (PoW).",
          benchTitle: "Menuiserie",
          benchDesc: "Construisez un √©tabli (partag√©).",
          toolTitle: "Outils",
          toolDesc: "Fabriquez un outil (Hache ou Pioche)."
        }
      },

      zh: {
        ui: { close: "ÂÖ≥Èó≠", language: "ËØ≠Ë®Ä" },
        hud: { room: "ÊàøÈó¥", peers: "Áé©ÂÆ∂", you: "‰Ω†", weight: "Ë¥üÈáç" },
        btn: { quests: "‰ªªÂä°", skills: "ÊäÄËÉΩ", craft: "Âà∂‰Ωú", world: "‰∏ñÁïå", credits: "È∏£Ë∞¢", export: "ÂØºÂá∫", import: "ÂØºÂÖ•", action: "Ë°åÂä® (E)", attack: "ÊîªÂáª (Á©∫Ê†º)" },
        login: {
          tagline: "Á®ãÂ∫èÁîüÊàêÁ≠âË∑ù‰∏ñÁïå + ÁîüÂ≠ò + P2PÔºàWebRTCÔºâ+ Á≠æÂêçËøΩÂä†ÂºèË¥¶Êú¨„ÄÇ",
          shareHint: "ÔºàÁî®‰ª•‰∏ãÂèÇÊï∞ÂàÜ‰∫´Ôºâ",
          nameLabel: "ËßíËâ≤Âêç",
          passLabel: "Âè£‰ª§Ôºà‰ªÖ‰øùÂ≠òÂú®Êú¨Êú∫Ôºâ",
          lifestyleLabel: "ÁîüÊ¥ªÊñπÂºè",
          optionsLabel: "ÈÄâÈ°π",
          enterWorld: "ËøõÂÖ•‰∏ñÁïå",
          copyLink: "Â§çÂà∂ÈìæÊé•",
          controls: "Êìç‰ΩúÔºöWASD/ÊñπÂêëÈîÆÔºåE Ë°åÂä®ÔºåÁ©∫Ê†º ÊîªÂáªÔºåÂõûËΩ¶ ËÅäÂ§©",
          ledgerNote: "ÂÖ±‰∫´Ë¥¶Êú¨ÊâÄÊúâ‰∫∫ÂèØËØªÔºå‰ΩÜÊ≤°‰∫∫ËÉΩ‚ÄúÊõø‰Ω†Á≠æÂêç‚ÄùÔºåÂõ†Ê≠§Êó†Ê≥ïÁØ°Êîπ‰Ω†ÁöÑÊâÄÊúâÁâ©„ÄÇ"
        },
        sel: { rememberNo: "‰∏çËÆ∞‰ΩèÂè£‰ª§", rememberYes: "ËÆ∞‰ΩèÂè£‰ª§Ôºà‰∏çÊé®ËçêÔºâ" },
        life: {
          Explorer: "Êé¢Èô©ËÄÖÔºàÊé¢Á¥¢+ËÄêÂäõÔºâ",
          Crafter: "Â∑•Âå†ÔºàÂà∂‰Ωú+Âª∫ÈÄ†Ôºâ",
          Hunter: "Áåé‰∫∫ÔºàÊàòÊñó+ÊéâËêΩÔºâ",
          Scholar: "Â≠¶ËÄÖÔºàÁ¨¶Êñá+Áü•ËØÜÔºâ",
          Merchant: "ÂïÜ‰∫∫ÔºàÁ§æ‰∫§+ÂÆûÁî®Ôºâ",
          Mystic: "ÁßòÊúØÂ∏àÔºà‰ª™Âºè+Â§úÊôöÔºâ"
        },
        modal: {
          language: "ËØ≠Ë®Ä", quests: "‰ªªÂä°ÔºàËøõÂ∫¶Ôºâ", skills: "ÊäÄËÉΩ+È£éÊ†º", world: "ÂÖ±‰∫´‰∏ñÁïåÔºàË¥¶Êú¨Ôºâ",
          credits: "È∏£Ë∞¢‰∏éËÆ∏ÂèØ", craft: "Âà∂‰ΩúÔºàÂ∑•ÂÖ∑/Ë£ÖÂ§á/Âª∫ÈÄ†Ôºâ", sign: "ÂëäÁ§∫Áâå",
          author: "‰ΩúËÄÖ", removeMine: "ÁßªÈô§Ôºà‰ªÖ‰Ω†Ôºâ", summary: "Ê¶ÇËßà", ranking: "ÊéíË°åÔºàÂú£ÂùõÔºâ",
          tip: "ÊèêÁ§∫ÔºöÂÖ±‰∫´Áâ©‰Ωì‰∏çÂèØÊõ¥ÊîπÔºõÂè™ÊúâÊã•ÊúâËÄÖÊâçËÉΩÁ≠æÂêçÁßªÈô§„ÄÇ",
          recipesBasic: "Âü∫Á°ÄÈÖçÊñπ", recipesAdv: "È´òÁ∫ßÔºàÈúÄÈôÑËøëÊúâÂ∑•‰ΩúÂè∞Ôºâ",
          materials: "ÊùêÊñô", currentEquip: "ÂΩìÂâçË£ÖÂ§á", position: "‰ΩçÁΩÆ"
        },
        common: { progress: "ËøõÂ∫¶", completed: "Â∑≤ÂÆåÊàê", reward: "Â•ñÂä±" },
        names: {
          biomes: { Water:"Ê∞¥Âüü", Swamp:"Ê≤ºÊ≥Ω", Forest:"Ê£ÆÊûó", Grass:"ËçâÂéü", Stone:"Áü≥Âú∞", Sand:"Ê≤ôÂú∞", Mount:"Â±±Âú∞", Snow:"Èõ™Âéü" },
          monsters: { Slime:"Âè≤Ëé±ÂßÜ", Wolf:"Áãº", Bandit:"Âº∫Áõó", Wisp:"È¨ºÁÅ´" },
          items: {
            Axe:"Êñß", Pickaxe:"Èïê", Campfire:"ÁØùÁÅ´", Workbench:"Â∑•‰ΩúÂè∞", Signpost:"ÂëäÁ§∫Áâå",
            Spear:"ÈïøÁüõ", Sword:"Ââë", Cloak:"ÊñóÁØ∑", Leather:"ÁöÆÁî≤", Lantern:"ÁÅØÁ¨º"
          },
          decor: { Tree:"Ê†ë", Rock:"Â≤©Áü≥", Bush:"ÁÅåÊú®", Ore:"ÁüøËÑâ", Herb:"ËçâËçØ", Bones:"È™®È™∏", Ruins:"ÈÅóËøπ", Shrine:"Âú£Âùõ" }
        },
        toast: {
          linkCopied: "ÈìæÊé•Â∑≤Â§çÂà∂",
          p2pOffline: "P2P ‰∏çÂèØÁî®ÔºàÁ¶ªÁ∫ø + ÂØºÂá∫/ÂØºÂÖ•Ôºâ",
          importOk: "ÂØºÂÖ•ÊàêÂäü",
          importFail: "ÂØºÂÖ•Â§±Ë¥•",
          chooseName: "ËØ∑ËæìÂÖ•ÂêçÂ≠ó",
          choosePass: "ËØ∑ËæìÂÖ•Âè£‰ª§",
          welcome: "Ê¨¢ËøéÊù•Âà∞ ShardwalkÔºÅ",
          deepWater: "Ê∑±Ê∞¥ÔºöÊó†Ê≥ïÈÄöËøá",
          newBiome: "ÂèëÁé∞Êñ∞Âú∞ÂΩ¢Ôºö{biome}",
          spawned: "Âá∫Áé∞Ôºö{monster}",
          mining: "Ê≠£Âú®ÊåñÁüø PoW‚Ä¶ ÁÇπÂáªË°åÂä®ÂèñÊ∂à",
          miningCancelled: "Â∑≤ÂèñÊ∂à",
          shrineClaimed: "Â∑≤Âç†È¢ÜÂú£ÂùõÔºÅ",
          rest: "‰Ω†Âú®ÁØùÁÅ´ÊóÅ‰ºëÊÅØ",
          benchNeeded: "ÈúÄË¶ÅÈôÑËøëÊúâÂ∑•‰ΩúÂè∞",
          ruinsAlready: "ËøôÈáåÁöÑÈÅóËøπÂ∑≤ÊêúËøá",
          ruinsLoot: "ÈÅóËøπÊàòÂà©ÂìÅÔºö{loot}",
          needPickaxe: "ÈúÄË¶ÅÈïêÊâçËÉΩÈááÁüø",
          nothing: "ËøôÈáåÊ≤°‰ªÄ‰πàÂèØÂÅö",
          noEnemies: "ÈôÑËøëÊ≤°ÊúâÊïå‰∫∫",
          hit: "ÂëΩ‰∏≠ÔºÅ-{dmg}",
          enemyDefeated: "ÂáªË¥•Êïå‰∫∫ÔºÅÊàòÂà©ÂìÅÔºö{loot}",
          youFell: "‰Ω†ÂÄí‰∏ã‰∫Ü‚Ä¶ ÂõûÂà∞Ëµ∑ÁÇπ",
          notEnough: "ÊùêÊñô‰∏çË∂≥",
          equipped: "Â∑≤Ë£ÖÂ§áÔºö{item}",
          placedShared: "Â∑≤ÊîæÁΩÆÔºàÂÖ±‰∫´ÔºâÔºö{item}",
          ateBerry: "‰Ω†ÂêÉ‰∫Ü‰∏ÄÈ¢óËéìÊûú",
          msgSent: "Ê∂àÊÅØÂ∑≤ÂèëÈÄÅ"
        },
        prompt: {
          signText: "ÂëäÁ§∫ÁâåÂÜÖÂÆπÔºàÊúÄÂ§ö160ÔºâÔºö",
          signDefault: "Ë∑ØÈÄîÊº´ÈïøÔºåËÆ©Á¢éÁâáÊåáÂºï‰Ω†„ÄÇ",
          chat: "ËØ¥ÁÇπ‰ªÄ‰πàÔºàP2PÔºå‰∏¥Êó∂ÔºâÔºö",
          chatDefault: "‰Ω†Â•ΩÔºÅ"
        },
        quest: {
          cartoTitle: "Âà∂ÂõæÂ∏à",
          cartoDesc: "Á¥ØËÆ°ÂèëÁé∞ {n} ÁßçÊñ∞Âú∞ÂΩ¢„ÄÇ",
          gatherTitle: "ÁîüÂ≠òËÄÖ",
          gatherDesc: "Êî∂ÈõÜ {n} Ê¨°ËµÑÊ∫êÔºàÊ†ë/Áü≥/Áüø/ËçâËçØ/ÈÅóËøπÔºâ„ÄÇ",
          valorTitle: "ÂãáÊ∞îËØïÁÇº",
          valorDesc: "ÂáªË¥• {n} ‰∏™Êïå‰∫∫„ÄÇ",
          shrineTitle: "ËøúÂè§Á¨¶Êñá",
          shrineDesc: "Âç†È¢Ü {n} ‰∏™Âú£ÂùõÔºàPoWÔºâ„ÄÇ",
          benchTitle: "Êú®Â∑•",
          benchDesc: "Âª∫ÈÄ†‰∏Ä‰∏™Â∑•‰ΩúÂè∞ÔºàÂÖ±‰∫´Ôºâ„ÄÇ",
          toolTitle: "Â∑•ÂÖ∑",
          toolDesc: "Âà∂‰Ωú‰∏Ä‰∏™Â∑•ÂÖ∑ÔºàÊñßÊàñÈïêÔºâ„ÄÇ"
        }
      },

      hi: {
        ui: { close: "‡§¨‡§Ç‡§¶ ‡§ï‡§∞‡•á‡§Ç", language: "‡§≠‡§æ‡§∑‡§æ" },
        hud: { room: "‡§ï‡§ï‡•ç‡§∑", peers: "‡§ñ‡§ø‡§≤‡§æ‡§°‡§º‡•Ä", you: "‡§Ü‡§™", weight: "‡§≠‡§æ‡§∞" },
        btn: { quests: "‡§ï‡•ç‡§µ‡•á‡§∏‡•ç‡§ü", skills: "‡§∏‡•ç‡§ï‡§ø‡§≤‡•ç‡§∏", craft: "‡§ï‡•ç‡§∞‡§æ‡§´‡•ç‡§ü", world: "‡§¶‡•Å‡§®‡§ø‡§Ø‡§æ", credits: "‡§ï‡•ç‡§∞‡•á‡§°‡§ø‡§ü‡•ç‡§∏", export: "‡§è‡§ï‡•ç‡§∏‡§™‡•ã‡§∞‡•ç‡§ü", import: "‡§á‡§Æ‡•ç‡§™‡•ã‡§∞‡•ç‡§ü", action: "‡§è‡§ï‡•ç‡§∂‡§® (E)", attack: "‡§Ö‡§ü‡•à‡§ï (‚ê£)" },
        login: {
          tagline: "‡§™‡•ç‡§∞‡•ã‡§∏‡•Ä‡§ú‡§∞‡§≤ ‡§Ü‡§á‡§∏‡•ã‡§Æ‡•á‡§ü‡•ç‡§∞‡§ø‡§ï ‡§¶‡•Å‡§®‡§ø‡§Ø‡§æ + ‡§∏‡§∞‡•ç‡§µ‡§æ‡§á‡§µ‡§≤ + P2P (WebRTC) + ‡§∏‡§æ‡§á‡§® ‡§ï‡§ø‡§Ø‡§æ ‡§π‡•Å‡§Ü append-only ‡§≤‡•á‡§ú‡§∞‡•§",
          shareHint: "(‡§á‡§∏ ‡§§‡§∞‡§π ‡§∂‡•á‡§Ø‡§∞ ‡§ï‡§∞‡•á‡§Ç)",
          nameLabel: "‡§ï‡§ø‡§∞‡§¶‡§æ‡§∞ ‡§ï‡§æ ‡§®‡§æ‡§Æ",
          passLabel: "‡§™‡§æ‡§∏‡§´‡§º‡•ç‡§∞‡•á‡§ú‡§º (‡§°‡§ø‡§µ‡§æ‡§á‡§∏ ‡§™‡§∞ ‡§π‡•Ä ‡§∞‡§π‡§§‡§æ ‡§π‡•à)",
          lifestyleLabel: "‡§≤‡§æ‡§á‡§´‡§∏‡•ç‡§ü‡§æ‡§á‡§≤",
          optionsLabel: "‡§µ‡§ø‡§ï‡§≤‡•ç‡§™",
          enterWorld: "‡§¶‡•Å‡§®‡§ø‡§Ø‡§æ ‡§Æ‡•á‡§Ç ‡§™‡•ç‡§∞‡§µ‡•á‡§∂",
          copyLink: "‡§≤‡§ø‡§Ç‡§ï ‡§ï‡•â‡§™‡•Ä",
          controls: "‡§ï‡§Ç‡§ü‡•ç‡§∞‡•ã‡§≤: WASD/‡§è‡§∞‡•ã, E ‡§è‡§ï‡•ç‡§∂‡§®, ‡§∏‡•ç‡§™‡•á‡§∏ ‡§Ö‡§ü‡•à‡§ï, ‡§è‡§Ç‡§ü‡§∞ ‡§ö‡•à‡§ü",
          ledgerNote: "‡§∂‡•á‡§Ø‡§∞ ‡§ï‡§ø‡§Ø‡§æ ‡§π‡•Å‡§Ü ‡§≤‡•á‡§ú‡§∞ ‡§∏‡§¨ ‡§™‡§¢‡§º ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç, ‡§≤‡•á‡§ï‡§ø‡§® ‡§ï‡•ã‡§à ‡§≠‡•Ä ‡§Ü‡§™‡§ï‡•á ‡§®‡§æ‡§Æ ‡§∏‡•á ‡§∏‡§æ‡§á‡§® ‡§®‡§π‡•Ä‡§Ç ‡§ï‡§∞ ‡§∏‡§ï‡§§‡§æ‚Äî‡§á‡§∏‡§≤‡§ø‡§è ‡§Ü‡§™‡§ï‡•Ä ‡§ö‡•Ä‡§ú‡§º‡•á‡§Ç ‡§®‡§π‡•Ä‡§Ç ‡§¨‡§¶‡§≤ ‡§∏‡§ï‡§§‡§æ‡•§"
        },
        sel: { rememberNo: "‡§™‡§æ‡§∏‡§´‡§º‡•ç‡§∞‡•á‡§ú‡§º ‡§Ø‡§æ‡§¶ ‡§® ‡§∞‡§ñ‡•á‡§Ç", rememberYes: "‡§™‡§æ‡§∏‡§´‡§º‡•ç‡§∞‡•á‡§ú‡§º ‡§Ø‡§æ‡§¶ ‡§∞‡§ñ‡•á‡§Ç (‡§Ö‡§®‡•Å‡§∂‡§Ç‡§∏‡§ø‡§§ ‡§®‡§π‡•Ä‡§Ç)" },
        life: {
          Explorer: "‡§è‡§ï‡•ç‡§∏‡§™‡•ç‡§≤‡•ã‡§∞‡§∞ (‡§ñ‡•ã‡§ú + ‡§∏‡§π‡§®‡§∂‡§ï‡•ç‡§§‡§ø)",
          Crafter: "‡§ï‡•ç‡§∞‡§æ‡§´‡•ç‡§ü‡§∞ (‡§ï‡•ç‡§∞‡§æ‡§´‡•ç‡§ü + ‡§®‡§ø‡§∞‡•ç‡§Æ‡§æ‡§£)",
          Hunter: "‡§π‡§Ç‡§ü‡§∞ (‡§≤‡§°‡§º‡§æ‡§à + ‡§≤‡•Ç‡§ü)",
          Scholar: "‡§∏‡•ç‡§ï‡•â‡§≤‡§∞ (‡§∞‡•Ç‡§®‡•ç‡§∏ + ‡§ú‡•ç‡§û‡§æ‡§®)",
          Merchant: "‡§Æ‡§∞‡•ç‡§ö‡•á‡§Ç‡§ü (‡§∏‡•ã‡§∂‡§≤ + ‡§â‡§™‡§Ø‡•ã‡§ó‡§ø‡§§‡§æ)",
          Mystic: "‡§Æ‡§ø‡§∏‡•ç‡§ü‡§ø‡§ï (‡§∞‡§ø‡§ö‡•Å‡§Ö‡§≤ + ‡§∞‡§æ‡§§)"
        },
        modal: {
          language: "‡§≠‡§æ‡§∑‡§æ", quests: "‡§ï‡•ç‡§µ‡•á‡§∏‡•ç‡§ü (‡§™‡•ç‡§∞‡§ó‡§§‡§ø)", skills: "‡§∏‡•ç‡§ï‡§ø‡§≤‡•ç‡§∏ + ‡§∏‡•ç‡§ü‡§æ‡§á‡§≤", world: "‡§∏‡§æ‡§ù‡§æ ‡§¶‡•Å‡§®‡§ø‡§Ø‡§æ (‡§≤‡•á‡§ú‡§∞)",
          credits: "‡§ï‡•ç‡§∞‡•á‡§°‡§ø‡§ü‡•ç‡§∏ ‡§µ ‡§≤‡§æ‡§á‡§∏‡•á‡§Ç‡§∏", craft: "‡§ï‡•ç‡§∞‡§æ‡§´‡•ç‡§ü (‡§ü‡•Ç‡§≤/‡§ó‡§ø‡§Ø‡§∞/‡§¨‡§ø‡§≤‡•ç‡§°)", sign: "‡§∏‡§æ‡§á‡§®‡§¨‡•ã‡§∞‡•ç‡§°",
          author: "‡§≤‡•á‡§ñ‡§ï", removeMine: "‡§π‡§ü‡§æ‡§è‡§Å (‡§∏‡§ø‡§∞‡•ç‡§´ ‡§Ü‡§™)", summary: "‡§∏‡§æ‡§∞", ranking: "‡§∞‡•à‡§Ç‡§ï‡§ø‡§Ç‡§ó (‡§∂‡•ç‡§∞‡§æ‡§á‡§®)",
          tip: "‡§ü‡§ø‡§™: ‡§∏‡§æ‡§ù‡§æ ‡§ë‡§¨‡•ç‡§ú‡•á‡§ï‡•ç‡§ü ‡§¨‡§¶‡§≤ ‡§®‡§π‡•Ä‡§Ç ‡§∏‡§ï‡§§‡•á; ‡§ï‡•á‡§µ‡§≤ ‡§Æ‡§æ‡§≤‡§ø‡§ï ‡§∏‡§æ‡§á‡§® ‡§ï‡§∞‡§ï‡•á ‡§π‡§ü‡§æ ‡§∏‡§ï‡§§‡§æ ‡§π‡•à‡•§",
          recipesBasic: "‡§¨‡•á‡§∏‡§ø‡§ï ‡§∞‡•á‡§∏‡§ø‡§™‡•Ä", recipesAdv: "‡§è‡§°‡§µ‡§æ‡§Ç‡§∏ (‡§™‡§æ‡§∏ ‡§Æ‡•á‡§Ç ‡§µ‡§∞‡•ç‡§ï‡§¨‡•á‡§Ç‡§ö ‡§ö‡§æ‡§π‡§ø‡§è)",
          materials: "‡§∏‡§æ‡§Æ‡§ó‡•ç‡§∞‡•Ä", currentEquip: "‡§µ‡§∞‡•ç‡§§‡§Æ‡§æ‡§® ‡§â‡§™‡§ï‡§∞‡§£", position: "‡§∏‡•ç‡§•‡§ø‡§§‡§ø"
        },
        common: { progress: "‡§™‡•ç‡§∞‡§ó‡§§‡§ø", completed: "‡§™‡•Ç‡§∞‡•ç‡§£", reward: "‡§á‡§®‡§æ‡§Æ" },
        names: {
          biomes: { Water:"‡§™‡§æ‡§®‡•Ä", Swamp:"‡§¶‡§≤‡§¶‡§≤", Forest:"‡§ú‡§Ç‡§ó‡§≤", Grass:"‡§ò‡§æ‡§∏‡§≠‡•Ç‡§Æ‡§ø", Stone:"‡§™‡§§‡•ç‡§•‡§∞", Sand:"‡§∞‡•á‡§§", Mount:"‡§™‡§π‡§æ‡§°‡§º", Snow:"‡§¨‡§∞‡•ç‡§´" },
          monsters: { Slime:"‡§∏‡•ç‡§≤‡§æ‡§á‡§Æ", Wolf:"‡§≠‡•á‡§°‡§º‡§ø‡§Ø‡§æ", Bandit:"‡§°‡§æ‡§ï‡•Ç", Wisp:"‡§µ‡§ø‡§∏‡•ç‡§™" },
          items: {
            Axe:"‡§ï‡•Å‡§≤‡•ç‡§π‡§æ‡§°‡§º‡•Ä", Pickaxe:"‡§ï‡•Å‡§¶‡§æ‡§≤/‡§™‡§ø‡§ï", Campfire:"‡§Ö‡§≤‡§æ‡§µ", Workbench:"‡§µ‡§∞‡•ç‡§ï‡§¨‡•á‡§Ç‡§ö", Signpost:"‡§∏‡§æ‡§á‡§®‡§¨‡•ã‡§∞‡•ç‡§°",
            Spear:"‡§≠‡§æ‡§≤‡§æ", Sword:"‡§§‡§≤‡§µ‡§æ‡§∞", Cloak:"‡§ï‡•ç‡§≤‡•ã‡§ï", Leather:"‡§ö‡§Æ‡§°‡§º‡•á ‡§ï‡§æ ‡§ï‡§µ‡§ö", Lantern:"‡§≤‡§æ‡§≤‡§ü‡•á‡§®"
          },
          decor: { Tree:"‡§™‡•á‡§°‡§º", Rock:"‡§ö‡§ü‡•ç‡§ü‡§æ‡§®", Bush:"‡§ù‡§æ‡§°‡§º‡•Ä", Ore:"‡§Ö‡§Ø‡§∏‡•ç‡§ï", Herb:"‡§ú‡§°‡§º‡•Ä-‡§¨‡•Ç‡§ü‡•Ä", Bones:"‡§π‡§°‡•ç‡§°‡§ø‡§Ø‡§æ‡§Å", Ruins:"‡§ñ‡§Ç‡§°‡§π‡§∞", Shrine:"‡§∂‡•ç‡§∞‡§æ‡§á‡§®" }
        },
        toast: {
          linkCopied: "‡§≤‡§ø‡§Ç‡§ï ‡§ï‡•â‡§™‡•Ä ‡§π‡•Å‡§Ü",
          p2pOffline: "P2P ‡§â‡§™‡§≤‡§¨‡•ç‡§ß ‡§®‡§π‡•Ä‡§Ç (‡§ë‡§´‡§≤‡§æ‡§á‡§® + ‡§è‡§ï‡•ç‡§∏‡§™‡•ã‡§∞‡•ç‡§ü/‡§á‡§Æ‡•ç‡§™‡•ã‡§∞‡•ç‡§ü)",
          importOk: "‡§á‡§Æ‡•ç‡§™‡•ã‡§∞‡•ç‡§ü OK",
          importFail: "‡§á‡§Æ‡•ç‡§™‡•ã‡§∞‡•ç‡§ü ‡§´‡•á‡§≤",
          chooseName: "‡§®‡§æ‡§Æ ‡§ö‡•Å‡§®‡•á‡§Ç",
          choosePass: "‡§™‡§æ‡§∏‡§´‡§º‡•ç‡§∞‡•á‡§ú‡§º ‡§≤‡§ø‡§ñ‡•á‡§Ç",
          welcome: "Shardwalk ‡§Æ‡•á‡§Ç ‡§∏‡•ç‡§µ‡§æ‡§ó‡§§ ‡§π‡•à!",
          deepWater: "‡§ó‡§π‡§∞‡§æ ‡§™‡§æ‡§®‡•Ä: ‡§Ü‡§ó‡•á ‡§®‡§π‡•Ä‡§Ç ‡§ú‡§æ ‡§∏‡§ï‡§§‡•á",
          newBiome: "‡§®‡§Ø‡§æ ‡§¨‡§æ‡§Ø‡•ã‡§Æ: {biome}",
          spawned: "‡§Ü ‡§ó‡§Ø‡§æ: {monster}",
          mining: "PoW ‡§Æ‡§æ‡§á‡§®‡§ø‡§Ç‡§ó‚Ä¶ ‡§è‡§ï‡•ç‡§∂‡§® ‡§¶‡§¨‡§æ‡§ï‡§∞ ‡§∞‡§¶‡•ç‡§¶ ‡§ï‡§∞‡•á‡§Ç",
          miningCancelled: "‡§∞‡§¶‡•ç‡§¶ ‡§ï‡§ø‡§Ø‡§æ",
          shrineClaimed: "‡§∂‡•ç‡§∞‡§æ‡§á‡§® ‡§ï‡•ç‡§≤‡•á‡§Æ ‡§π‡•ã ‡§ó‡§Ø‡§æ!",
          rest: "‡§Ü‡§™ ‡§Ö‡§≤‡§æ‡§µ ‡§ï‡•á ‡§™‡§æ‡§∏ ‡§Ü‡§∞‡§æ‡§Æ ‡§ï‡§∞‡§§‡•á ‡§π‡•à‡§Ç",
          benchNeeded: "‡§™‡§æ‡§∏ ‡§Æ‡•á‡§Ç ‡§µ‡§∞‡•ç‡§ï‡§¨‡•á‡§Ç‡§ö ‡§ö‡§æ‡§π‡§ø‡§è",
          ruinsAlready: "‡§Ø‡•á ‡§ñ‡§Ç‡§°‡§π‡§∞ ‡§™‡§π‡§≤‡•á ‡§π‡•Ä ‡§ñ‡•ã‡§ú‡•á ‡§ó‡§è",
          ruinsLoot: "‡§ñ‡§Ç‡§°‡§π‡§∞ ‡§≤‡•Ç‡§ü: {loot}",
          needPickaxe: "‡§Ö‡§Ø‡§∏‡•ç‡§ï ‡§ï‡•á ‡§≤‡§ø‡§è ‡§™‡§ø‡§ï ‡§ö‡§æ‡§π‡§ø‡§è",
          nothing: "‡§Ø‡§π‡§æ‡§Å ‡§ï‡•Å‡§õ ‡§®‡§π‡•Ä‡§Ç",
          noEnemies: "‡§™‡§æ‡§∏ ‡§Æ‡•á‡§Ç ‡§¶‡•Å‡§∂‡•ç‡§Æ‡§® ‡§®‡§π‡•Ä‡§Ç",
          hit: "‡§π‡§ø‡§ü! -{dmg}",
          enemyDefeated: "‡§¶‡•Å‡§∂‡•ç‡§Æ‡§® ‡§π‡§æ‡§∞‡§æ! ‡§≤‡•Ç‡§ü: {loot}",
          youFell: "‡§Ü‡§™ ‡§ó‡§ø‡§∞ ‡§ó‡§è‚Ä¶ ‡§∂‡•Å‡§∞‡•Å‡§Ü‡§§ ‡§™‡§∞ ‡§≤‡•å‡§ü‡•á",
          notEnough: "‡§∏‡§æ‡§Æ‡§ó‡•ç‡§∞‡•Ä ‡§ï‡§Æ ‡§π‡•à",
          equipped: "‡§á‡§ï‡•ç‡§µ‡§ø‡§™: {item}",
          placedShared: "‡§∞‡§ñ‡§æ ‡§ó‡§Ø‡§æ (‡§∏‡§æ‡§ù‡§æ): {item}",
          ateBerry: "‡§Ü‡§™‡§®‡•á ‡§¨‡•á‡§∞‡•Ä ‡§ñ‡§æ‡§à",
          msgSent: "‡§Æ‡•à‡§∏‡•á‡§ú ‡§≠‡•á‡§ú‡§æ"
        },
        prompt: {
          signText: "‡§∏‡§æ‡§á‡§®‡§¨‡•ã‡§∞‡•ç‡§° ‡§ü‡•á‡§ï‡•ç‡§∏‡•ç‡§ü (‡§Ö‡§ß‡§ø‡§ï‡§§‡§Æ 160):",
          signDefault: "‡§∞‡§æ‡§∏‡•ç‡§§‡§æ ‡§≤‡§Ç‡§¨‡§æ ‡§π‡•à‚Äî‡§∂‡§æ‡§∞‡•ç‡§° ‡§∞‡§æ‡§∏‡•ç‡§§‡§æ ‡§¶‡§ø‡§ñ‡§æ‡§è‡•§",
          chat: "‡§ï‡§π‡•á‡§Ç (P2P, ‡§Ö‡§∏‡•ç‡§•‡§æ‡§Ø‡•Ä):",
          chatDefault: "‡§®‡§Æ‡§∏‡•ç‡§§‡•á!"
        },
        quest: {
          cartoTitle: "‡§Æ‡§æ‡§®‡§ö‡§ø‡§§‡•ç‡§∞‡§ï‡§æ‡§∞",
          cartoDesc: "{n} ‡§®‡§è ‡§¨‡§æ‡§Ø‡•ã‡§Æ ‡§ñ‡•ã‡§ú‡•á‡§Ç (‡§ï‡•Å‡§≤).",
          gatherTitle: "‡§∏‡§∞‡•ç‡§µ‡§æ‡§á‡§µ‡§≤",
          gatherDesc: "{n} ‡§∏‡§Ç‡§∏‡§æ‡§ß‡§® ‡§á‡§ï‡§ü‡•ç‡§†‡§æ ‡§ï‡§∞‡•á‡§Ç (‡§™‡•á‡§°‡§º/‡§ö‡§ü‡•ç‡§ü‡§æ‡§®/‡§Ö‡§Ø‡§∏‡•ç‡§ï/‡§ú‡§°‡§º‡•Ä-‡§¨‡•Ç‡§ü‡•Ä/‡§ñ‡§Ç‡§°‡§π‡§∞).",
          valorTitle: "‡§∏‡§æ‡§π‡§∏ ‡§™‡§∞‡•Ä‡§ï‡•ç‡§∑‡§æ",
          valorDesc: "{n} ‡§¶‡•Å‡§∂‡•ç‡§Æ‡§®‡•ã‡§Ç ‡§ï‡•ã ‡§π‡§∞‡§æ‡§è‡§Å.",
          shrineTitle: "‡§™‡•ç‡§∞‡§æ‡§ö‡•Ä‡§® ‡§∞‡•Ç‡§£",
          shrineDesc: "{n} ‡§∂‡•ç‡§∞‡§æ‡§á‡§® ‡§ï‡•ç‡§≤‡•á‡§Æ ‡§ï‡§∞‡•á‡§Ç (PoW).",
          benchTitle: "‡§ï‡§æ‡§∞‡§™‡•á‡§Ç‡§ü‡•ç‡§∞‡•Ä",
          benchDesc: "‡§µ‡§∞‡•ç‡§ï‡§¨‡•á‡§Ç‡§ö ‡§¨‡§®‡§æ‡§è‡§Å (‡§∏‡§æ‡§ù‡§æ).",
          toolTitle: "‡§ü‡•Ç‡§≤‡•ç‡§∏",
          toolDesc: "‡§è‡§ï ‡§ü‡•Ç‡§≤ ‡§¨‡§®‡§æ‡§è‡§Å (‡§ï‡•Å‡§≤‡•ç‡§π‡§æ‡§°‡§º‡•Ä ‡§Ø‡§æ ‡§™‡§ø‡§ï)."
        }
      },

      ca: {
        ui: { close: "Tanca", language: "Idioma" },
        hud: { room: "Sala", peers: "Jugadors", you: "Tu", weight: "Pes" },
        btn: { quests: "Quests", skills: "Skills", craft: "Craft", world: "M√≥n", credits: "Cr√®dits", export: "Export", import: "Import", action: "Acci√≥ (E)", attack: "Atacar (‚ê£)" },
        login: {
          tagline: "M√≥n isom√®tric procedural + superviv√®ncia + P2P (WebRTC) + ledger signat (append-only).",
          shareHint: "(comparteix l‚Äôenlla√ß amb)",
          nameLabel: "Nom de personatge",
          passLabel: "Clau de pas (no surt del dispositiu)",
          lifestyleLabel: "Estil de vida",
          optionsLabel: "Opcions",
          enterWorld: "Entrar al m√≥n",
          copyLink: "Copia link",
          controls: "Controls: WASD/Fletxes, E acci√≥, Espai atacar, Enter xat",
          ledgerNote: "El ledger compartit √©s llegible per tothom, per√≤ ning√∫ pot ‚Äúsignar com tu‚Äù: no poden modificar el que √©s teu."
        },
        sel: { rememberNo: "No recordar clau", rememberYes: "Recordar clau (NO recomanat)" },
        life: {
          Explorer: "Explorer (exploraci√≥ + resist√®ncia)",
          Crafter: "Crafter (crafting + construcci√≥)",
          Hunter: "Hunter (combat + loot)",
          Scholar: "Scholar (runes + coneixement)",
          Merchant: "Merchant (social + utilitat)",
          Mystic: "Mystic (rituals + nit)"
        },
        modal: {
          language: "Idioma", quests: "Quests (progr√©s)", skills: "Skills + Lifestyle", world: "M√≥n compartit (ledger)",
          credits: "Cr√®dits i llic√®ncies", craft: "Craft (eines, equips, construcci√≥)", sign: "Cartell",
          author: "Autor", removeMine: "Eliminar (nom√©s tu)", summary: "Resum", ranking: "R√†nquing (santuaris)",
          tip: "Tip: els objectes compartits s√≥n inmutables; nom√©s el propietari els pot retirar (signant).",
          recipesBasic: "Receptes (b√†siques)", recipesAdv: "Avan√ßat (requereix Banc de Treball a prop)",
          materials: "Materials", currentEquip: "Equip actual", position: "Posici√≥"
        },
        common: { progress: "Progr√©s", completed: "completada", reward: "Recompensa" },
        names: {
          biomes: { Water:"Aigua", Swamp:"Pant√†", Forest:"Bosc", Grass:"Prat", Stone:"Pedra", Sand:"Sorra", Mount:"Muntanya", Snow:"Neu" },
          monsters: { Slime:"Slime", Wolf:"Llop", Bandit:"Bandit", Wisp:"Foc follet" },
          items: {
            Axe:"Destral", Pickaxe:"Pic", Campfire:"Foguera", Workbench:"Banc de Treball", Signpost:"Cartell",
            Spear:"Llan√ßa", Sword:"Espasa", Cloak:"Capa", Leather:"Armadura de cuir", Lantern:"Llanterna"
          },
          decor: { Tree:"Arbre", Rock:"Roca", Bush:"Arbust", Ore:"Veta", Herb:"Herbes", Bones:"Restes", Ruins:"Ru√Ønes", Shrine:"Santuari" }
        },
        toast: {
          linkCopied: "Link copiat",
          p2pOffline: "P2P no disponible (offline + export/import)",
          importOk: "Import OK",
          importFail: "Import fallit",
          chooseName: "Tria un nom",
          choosePass: "Escriu una clau de pas",
          welcome: "Benvingut/da a Shardwalk!",
          deepWater: "Aigua profunda: no pots passar",
          newBiome: "Nou biome: {biome}",
          spawned: "Apareix: {monster}",
          mining: "Minant PoW‚Ä¶ toca Acci√≥ per cancel¬∑lar",
          miningCancelled: "Mining cancel¬∑lat",
          shrineClaimed: "Santuari reclamat!",
          rest: "Descanses a la foguera",
          benchNeeded: "Necessites un Banc de Treball a prop",
          ruinsAlready: "Ja has escorcollat aquestes ru√Ønes",
          ruinsLoot: "Loot de ru√Ønes: {loot}",
          needPickaxe: "Necessites un Pic per minar",
          nothing: "Res a fer aqu√≠",
          noEnemies: "No hi ha enemics a prop",
          hit: "Cop! -{dmg}",
          enemyDefeated: "Enemic derrotat! Loot: {loot}",
          youFell: "Has caigut‚Ä¶ reapareixes a l'origen",
          notEnough: "No tens materials",
          equipped: "Equipat: {item}",
          placedShared: "Col¬∑locat (compartit): {item}",
          ateBerry: "Menges una baia",
          msgSent: "Missatge enviat"
        },
        prompt: {
          signText: "Text del cartell (max 160):",
          signDefault: "El cam√≠ √©s llarg; la shard guia.",
          chat: "Dir (P2P, ef√≠mer):",
          chatDefault: "Hola!"
        },
        quest: {
          cartoTitle: "Cart√≤graf/a",
          cartoDesc: "Descobreix {n} biomes nous (acumulat).",
          gatherTitle: "Superviv√®ncia",
          gatherDesc: "Recol¬∑lecta {n} recursos (arbre/roca/veta/herbes/ru√Ønes).",
          valorTitle: "Prova de Valor",
          valorDesc: "Derrota {n} enemics.",
          shrineTitle: "Runa Ancestral",
          shrineDesc: "Reclama {n} santuari (PoW).",
          benchTitle: "Fusteria",
          benchDesc: "Construeix un Banc de Treball (compartit).",
          toolTitle: "Eines",
          toolDesc: "Crafteja una eina (Destral o Pic)."
        }
      }
    };

    const LANGS = [
      { code:"en", label:"English", flag: FLAG.en },
      { code:"zh", label:"‰∏≠Êñá",    flag: FLAG.zh },
      { code:"hi", label:"‡§π‡§ø‡§®‡•ç‡§¶‡•Ä", flag: FLAG.hi },
      { code:"es", label:"Espa√±ol",flag: FLAG.es },
      { code:"fr", label:"Fran√ßais",flag: FLAG.fr },
      { code:"ca", label:"Catal√†", flag: FLAG.ca }
    ];

    function deepGet(obj, path){
      return path.split(".").reduce((o,k)=> (o && o[k] != null) ? o[k] : null, obj);
    }

    function t(key, vars){
      const lang = I18N[currentLang] || I18N.en;
      let s = deepGet(lang, key) ?? deepGet(I18N.en, key) ?? key;
      if (vars){
        s = s.replace(/\{(\w+)\}/g, (_,k)=> (vars[k] != null ? String(vars[k]) : `{${k}}`));
      }
      return s;
    }

    function applyI18n(){
      document.querySelectorAll("[data-i18n]").forEach(el=>{
        el.textContent = t(el.getAttribute("data-i18n"));
      });
    }

    function renderLifestyleOptions(){
      const lifeEl = document.getElementById("life");
      const keys = ["Explorer","Crafter","Hunter","Scholar","Merchant","Mystic"];
      lifeEl.innerHTML = keys.map(k=> `<option value="${k}">${escapeHtml(t("life."+k))}</option>`).join("");
    }

    function renderRememberOptions(){
      const rememberEl = document.getElementById("remember");
      rememberEl.innerHTML = `
        <option value="0">${escapeHtml(t("sel.rememberNo"))}</option>
        <option value="1">${escapeHtml(t("sel.rememberYes"))}</option>
      `;
    }

    function renderLangPicker(containerId){
      const el = document.getElementById(containerId);
      el.innerHTML = LANGS.map(L => `
        <button class="langbtn" data-lang="${L.code}" aria-pressed="${L.code===currentLang}" title="${escapeHtml(L.label)}" aria-label="${escapeHtml(L.label)}">
          <img class="flag" src="${L.flag}" alt="${escapeHtml(L.label)}" />
        </button>
      `).join("");

      el.querySelectorAll("button[data-lang]").forEach(btn=>{
        btn.addEventListener("click", ()=>{
          setLanguage(btn.getAttribute("data-lang"));
          // refresh pressed state
          renderLangPicker(containerId);
        });
      });
    }

    function setLanguage(lang){
      if (!I18N[lang]) lang = "en";
      currentLang = lang;
      localStorage.setItem("sw_lang", currentLang);
      document.documentElement.lang = currentLang;
      document.title = GAME_TITLE;

      // flag on HUD button
      const langIcon = document.getElementById("langIcon");
      if (langIcon) langIcon.src = FLAG[currentLang];

      applyI18n();
      renderLifestyleOptions();
      renderRememberOptions();

      // refresh dynamic labels
      refreshHud();
    }

    function escapeHtml(s){
      return String(s).replace(/[&<>"']/g, c => ({
        "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
      })[c]);
    }

    // initial language
    let currentLang = (new URLSearchParams(location.search).get("lang") || localStorage.getItem("sw_lang") || "").toLowerCase();
    if (!I18N[currentLang]){
      const nav = (navigator.language || "en").toLowerCase();
      if (nav.startsWith("ca")) currentLang = "ca";
      else if (nav.startsWith("es")) currentLang = "es";
      else if (nav.startsWith("fr")) currentLang = "fr";
      else if (nav.startsWith("zh")) currentLang = "zh";
      else if (nav.startsWith("hi")) currentLang = "hi";
      else currentLang = "en";
    }

    // ============================================================
    // Existing game code (unchanged logic) + translated strings
    // ============================================================
    const te = new TextEncoder();

    const toastEl = document.getElementById("toast");
    function toast(msg, ms=1200){
      toastEl.textContent = msg;
      toastEl.style.display = "block";
      clearTimeout(toastEl._t);
      toastEl._t = setTimeout(()=> toastEl.style.display="none", ms);
    }

    function u8cat(a,b){
      const out = new Uint8Array(a.length + b.length);
      out.set(a,0); out.set(b,a.length);
      return out;
    }

    function toBase64(u8){
      let s = "";
      const chunk = 0x8000;
      for (let i=0; i<u8.length; i+=chunk){
        s += String.fromCharCode(...u8.subarray(i, i+chunk));
      }
      return btoa(s);
    }
    function fromBase64(b64){
      const bin = atob(b64);
      const out = new Uint8Array(bin.length);
      for (let i=0; i<bin.length; i++) out[i] = bin.charCodeAt(i);
      return out;
    }

    function stableStringify(obj){ return JSON.stringify(sortKeys(obj)); }
    function sortKeys(x){
      if (x === null || typeof x !== "object") return x;
      if (Array.isArray(x)) return x.map(sortKeys);
      const out = {};
      for (const k of Object.keys(x).sort()) out[k] = sortKeys(x[k]);
      return out;
    }

    function hashHexFromBodyAndSig(bodyStr, sigU8){
      const msgU8 = te.encode(bodyStr);
      return bytesToHex(sha256(u8cat(msgU8, sigU8)));
    }

    function randCode(){ return Math.random().toString(36).slice(2, 8); }
    function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }
    function mod(n,m){ return ((n%m)+m)%m; }

    function seedU32FromStr(str){
      const b = sha256(te.encode(str));
      return ((b[0]<<24) | (b[1]<<16) | (b[2]<<8) | (b[3])) >>> 0;
    }

    function hash2D01(seedU32, x, y){
      let h = (seedU32 ^ (x * 374761393) ^ (y * 668265263)) >>> 0;
      h = Math.imul(h ^ (h >>> 13), 1274126177) >>> 0;
      h = (h ^ (h >>> 16)) >>> 0;
      return h / 4294967296;
    }

    // Room
    const params = new URLSearchParams(location.search);
    const roomId = params.get("room") || localStorage.getItem("sw_last_room") || randCode();
    localStorage.setItem("sw_last_room", roomId);
    document.getElementById("roomLabel").textContent = roomId;

    // Modal
    const modal = document.getElementById("modal");
    const modalTitle = document.getElementById("modalTitle");
    const modalBody = document.getElementById("modalBody");
    document.getElementById("closeModal").onclick = () => modal.style.display = "none";
    modal.addEventListener("click", (e)=>{ if (e.target === modal) modal.style.display = "none"; });
    function showModal(title, html){
      modalTitle.textContent = title;
      modalBody.innerHTML = html;
      modal.style.display = "flex";
    }

    // Language modal (any time)
    document.getElementById("btnLang").onclick = () => {
      showModal(t("modal.language"), `
        <div class="card" style="display:flex;gap:8px;flex-wrap:wrap">
          ${LANGS.map(L=>`
            <button class="langbtn" data-lang="${L.code}">
              <img class="flag" src="${L.flag}" alt="${escapeHtml(L.label)}" />
              <span>${escapeHtml(L.label)}</span>
            </button>
          `).join("")}
        </div>
      `);
      setTimeout(()=>{
        modalBody.querySelectorAll("button[data-lang]").forEach(b=>{
          b.onclick = ()=> {
            setLanguage(b.getAttribute("data-lang"));
            modal.style.display = "none";
          };
        });
      },0);
    };

    // Copy link
    document.getElementById("copyLink").onclick = async () => {
      const url = new URL(location.href);
      url.searchParams.set("room", roomId);
      await navigator.clipboard.writeText(url.toString());
      toast(t("toast.linkCopied"));
    };

    // Identity
    const loginEl = document.getElementById("login");
    const nameEl = document.getElementById("name");
    const passEl = document.getElementById("pass");
    const lifeEl = document.getElementById("life");
    const rememberEl = document.getElementById("remember");

    const lastName = localStorage.getItem(`sw_${roomId}_name`) || `Traveler-${randCode()}`;
    const lastLife = localStorage.getItem(`sw_${roomId}_life`) || "Explorer";
    nameEl.value = lastName;

    // Shared ledger
    const LEDGER_KEY = `sw_${roomId}_ledger_v2`;
    const LOCAL_KEY = (pub) => `sw_${roomId}_local_v2_${pub}`;

    function loadLedgerRaw(){
      try { return JSON.parse(localStorage.getItem(LEDGER_KEY) || "null"); }
      catch { return null; }
    }
    function saveLedgerRaw(raw){
      localStorage.setItem(LEDGER_KEY, JSON.stringify(raw));
    }
    function loadLocal(pub){
      try { return JSON.parse(localStorage.getItem(LOCAL_KEY(pub)) || "null"); }
      catch { return null; }
    }
    function saveLocal(pub, obj){
      localStorage.setItem(LOCAL_KEY(pub), JSON.stringify(obj));
    }

    const ledger = {
      raw: loadLedgerRaw() || { v:1, room: roomId, authors: {} },
      byId: new Map(),
      byAuthor: new Map(),
      profiles: new Map(),
      objects: new Map(),
      objectsByPos: new Map(),
      shrineClaims: new Map(),
      score: new Map()
    };

    function powHashHex(shrineId, pubB64, nonceStr){
      const u8 = te.encode(`pow:${shrineId}:${pubB64}:${nonceStr}`);
      return bytesToHex(sha256(u8));
    }
    function meetsPowBits(hexHash, bits){
      const fullNibbles = Math.floor(bits / 4);
      const remBits = bits % 4;
      for (let i=0; i<fullNibbles; i++){
        if (hexHash[i] !== "0") return false;
      }
      if (remBits === 0) return true;
      const nibble = parseInt(hexHash[fullNibbles], 16);
      return (nibble >> (4 - remBits)) === 0;
    }

    function verifyEventBasic(ev){
      try {
        if (!ev || ev.v !== 1 || ev.room !== roomId) return { ok:false };
        if (!ev.author || !ev.sig || !ev.id) return { ok:false };

        const sigU8 = fromBase64(ev.sig);
        const pubU8 = fromBase64(ev.author);
        const { id, sig, ...body } = ev;
        const bodyStr = stableStringify(body);
        const id2 = hashHexFromBodyAndSig(bodyStr, sigU8);
        if (id2 !== ev.id) return { ok:false };

        const msgU8 = te.encode(bodyStr);
        const okSig = nacl.sign.detached.verify(msgU8, sigU8, pubU8);
        if (!okSig) return { ok:false };

        if (ev.type === "PROFILE"){
          const p = ev.payload || {};
          if (!p.name || !p.lifestyle) return { ok:false };
        }
        if (ev.type === "PLACE_OBJECT"){
          const p = ev.payload || {};
          if (!p.objectId || !p.kind) return { ok:false };
          if (!Number.isFinite(p.x) || !Number.isFinite(p.y)) return { ok:false };
        }
        if (ev.type === "REMOVE_OBJECT"){
          const p = ev.payload || {};
          if (!p.objectId) return { ok:false };
        }
        if (ev.type === "CLAIM_SHRINE"){
          const p = ev.payload || {};
          if (!p.shrineId || !p.powNonce || !p.powHash) return { ok:false };
          const bits = clamp(p.powBits|0, 8, 22);
          const chk = powHashHex(p.shrineId, ev.author, String(p.powNonce));
          if (chk !== String(p.powHash)) return { ok:false };
          if (!meetsPowBits(chk, bits)) return { ok:false };
        }
        return { ok:true };
      } catch { return { ok:false }; }
    }

    function rebuildLedgerIndexes(){
      ledger.byId.clear();
      ledger.byAuthor.clear();
      ledger.profiles.clear();
      ledger.objects.clear();
      ledger.objectsByPos.clear();
      ledger.shrineClaims.clear();
      ledger.score.clear();

      const cleanedAuthors = {};
      for (const [pub, eventsRaw] of Object.entries(ledger.raw.authors || {})){
        const arr = Array.isArray(eventsRaw) ? eventsRaw.slice() : [];
        arr.sort((a,b)=> (a.seq-b.seq));
        const st = { events: [], headId: null, seq: -1 };
        for (const ev of arr){
          if (!ev || ev.author !== pub) continue;
          const v = verifyEventBasic(ev);
          if (!v.ok) continue;
          if ((ev.seq|0) !== st.seq + 1) continue;
          if ((ev.prev||null) !== (st.headId||null)) continue;

          st.events.push(ev);
          st.seq = ev.seq|0;
          st.headId = ev.id;
          ledger.byId.set(ev.id, ev);
        }
        if (st.events.length){
          ledger.byAuthor.set(pub, st);
          cleanedAuthors[pub] = st.events;
        }
      }
      ledger.raw.authors = cleanedAuthors;

      const allEvents = [];
      for (const st of ledger.byAuthor.values()) for (const ev of st.events) allEvents.push(ev);

      for (const ev of allEvents){
        if (ev.type === "PROFILE"){
          const p = ev.payload || {};
          if (!ledger.profiles.has(ev.author)){
            ledger.profiles.set(ev.author, { name: String(p.name||"").slice(0,18), lifestyle: String(p.lifestyle||"Explorer") });
          }
        }
        if (ev.type === "PLACE_OBJECT"){
          const p = ev.payload || {};
          const objectId = p.objectId;
          if (!objectId) continue;
          if (!ledger.objects.has(objectId)){
            ledger.objects.set(objectId, {
              kind: p.kind, x: p.x|0, y: p.y|0, text: (p.text ? String(p.text).slice(0,160) : ""),
              ownerPub: ev.author, removed: false
            });
          }
        }
        if (ev.type === "REMOVE_OBJECT"){
          const p = ev.payload || {};
          const obj = ledger.objects.get(p.objectId);
          if (obj && obj.ownerPub === ev.author) obj.removed = true;
        }
      }

      for (const obj of ledger.objects.values()){
        if (!obj || obj.removed) continue;
        const k = `${obj.x},${obj.y}`;
        if (!ledger.objectsByPos.has(k)) ledger.objectsByPos.set(k, []);
        ledger.objectsByPos.get(k).push(obj);
      }

      for (const ev of allEvents){
        if (ev.type !== "CLAIM_SHRINE") continue;
        const p = ev.payload || {};
        if (!p.shrineId || !p.powHash) continue;
        const cur = ledger.shrineClaims.get(p.shrineId);
        if (!cur || String(p.powHash) < String(cur.bestPowHash)){
          ledger.shrineClaims.set(p.shrineId, { bestPowHash:String(p.powHash), bestEventId:ev.id, pub:ev.author, x:p.x|0, y:p.y|0 });
        }
      }
      for (const win of ledger.shrineClaims.values()){
        ledger.score.set(win.pub, (ledger.score.get(win.pub) || 0) + 1);
      }
    }

    rebuildLedgerIndexes();

    function getAuthorState(pub){
      if (!ledger.byAuthor.has(pub)) ledger.byAuthor.set(pub, { events: [], headId: null, seq: -1 });
      return ledger.byAuthor.get(pub);
    }

    function appendEventToLedger(ev){
      const st = getAuthorState(ev.author);
      if (ev.seq !== st.seq + 1) return false;
      if ((st.headId || null) !== (ev.prev || null)) return false;
      st.events.push(ev);
      st.seq = ev.seq;
      st.headId = ev.id;
      if (!ledger.raw.authors[ev.author]) ledger.raw.authors[ev.author] = [];
      ledger.raw.authors[ev.author].push(ev);
      ledger.byId.set(ev.id, ev);
      return true;
    }

    let ledgerSaveTimer = null;
    function saveLedgerDebounced(){
      if (ledgerSaveTimer) return;
      ledgerSaveTimer = setTimeout(()=>{
        ledgerSaveTimer = null;
        saveLedgerRaw(ledger.raw);
      }, 200);
    }

    // P2P
    const APP_ID = "shardwalk-iso";
    const relayUrls = [
      "wss://tracker.openwebtorrent.com",
      "wss://tracker.webtorrent.dev",
      "wss://tracker.novage.com.ua"
    ];

    let room = null;
    let net = { enabled: false, peerCount: 0 };
    let sendHello, getHello;
    let sendMove,  getMove;
    let sendEv,    getEv;
    let sendGet,   getGet;
    let sendBatch, getBatch;
    let sendSay,   getSay;

    function headsSummary(){
      const heads = {};
      for (const [pub, st] of ledger.byAuthor.entries()) heads[pub] = st.seq;
      return heads;
    }

    // World gen
    const worldSeedU32 = seedU32FromStr(`world:${roomId}`);
    const BIOMES = [
      { id:"Water", key:"t_water" },
      { id:"Swamp", key:"t_swamp" },
      { id:"Forest",key:"t_forest" },
      { id:"Grass", key:"t_grass" },
      { id:"Stone", key:"t_stone" },
      { id:"Sand",  key:"t_sand" },
      { id:"Mount", key:"t_mount" },
      { id:"Snow",  key:"t_snow" }
    ];

    function biomeAt(tx, ty){
      const n = hash2D01(worldSeedU32, tx, ty);
      if (n < 0.12) return "Water";
      if (n < 0.22) return "Swamp";
      if (n < 0.38) return "Forest";
      if (n < 0.52) return "Grass";
      if (n < 0.66) return "Stone";
      if (n < 0.78) return "Sand";
      if (n < 0.90) return "Mount";
      return "Snow";
    }

    function decorAt(tx, ty, biome){
      const r0 = hash2D01(worldSeedU32 ^ 0xA5A5A5A5, tx, ty);
      if (biome !== "Water" && r0 < 0.0018) return "Ruins";

      const r = hash2D01(worldSeedU32 ^ 0x9e3779b9, tx, ty);
      if ((biome === "Stone" || biome === "Mount") && r < 0.12) return "Ore";
      if ((biome === "Grass" || biome === "Forest" || biome === "Swamp") && r < 0.10) return "Herb";
      if (biome === "Sand" && r < 0.08) return "Bones";
      if (biome === "Forest" && r < 0.22) return "Tree";
      if ((biome === "Stone" || biome === "Mount") && r < 0.22) return "Rock";
      if ((biome === "Grass" || biome === "Swamp") && r < 0.18) return "Bush";
      return null;
    }

    function shrineAt(tx, ty, biome){
      if (biome === "Water") return null;
      const r = hash2D01(worldSeedU32 ^ 0xBADC0FFE, tx, ty);
      if (r < 0.0055) {
        const shrineId = bytesToHex(sha256(te.encode(`shrine:${roomId}:${tx}:${ty}`)));
        return { shrineId, x: tx|0, y: ty|0 };
      }
      return null;
    }

    function tileKeyFromBiome(b){
      const entry = BIOMES.find(x=> x.id === b);
      return entry ? entry.key : "t_grass";
    }

    // Lifestyle + local state
    const LIFESTYLES = {
      Explorer: { mult: {Athletics:1.25, Survival:1.20, Lore:1.00, Crafting:1.00, Combat:1.00, Gathering:1.10}, start:{wood:1, stone:0, berry:2, fiber:1} },
      Crafter:  { mult: {Crafting:1.35, Gathering:1.20, Athletics:1.00, Survival:1.00, Combat:0.95, Lore:1.00}, start:{wood:3, stone:1, berry:0, fiber:0} },
      Hunter:   { mult: {Combat:1.35, Survival:1.15, Athletics:1.05, Crafting:0.95, Gathering:1.05}, start:{wood:1, stone:1, berry:1, hide:1} },
      Scholar:  { mult: {Lore:1.40, Crafting:1.05, Survival:0.95, Combat:0.90, Gathering:1.00}, start:{wood:0, stone:0, berry:3, shard:0} },
      Merchant: { mult: {Social:1.45, Crafting:1.05, Athletics:1.00, Survival:1.00}, start:{wood:2, stone:0, berry:1, fiber:1} },
      Mystic:   { mult: {Lore:1.25, Survival:1.05, Combat:1.00, Crafting:1.00, Gathering:1.00}, start:{wood:0, stone:1, berry:2, shard:0} }
    };

    function skillLevel(xp){ return Math.floor(Math.sqrt(Math.max(0, xp) / 110)); }

    function calcWeight(m){
      return (m.wood||0)*1 + (m.stone||0)*2 + (m.ore||0)*2 + (m.fiber||0)*1 + (m.hide||0)*1 + (m.berry||0)*0.5 + (m.shard||0)*0.2;
    }
    function calcCapacity(){
      const ath = skillLevel(local.skills.Athletics||0);
      return 30 + ath*6;
    }

    let me = { name:"", lifestyle:"Explorer", pub:"", secretKey:null, peerId:(selfId||"").slice(0,8) };
    let local = null;

    function defaultLocalState(){
      return {
        v:2,
        player: { x: 0, y: 0 },
        stats: { hp:100, stamina:100, hunger:0 },
        mats: { wood:0, stone:0, ore:0, fiber:0, hide:0, shard:0, berry:0 },
        equip: { tool:null, weapon:null, armor:null, accessory:null },
        skills: { Athletics:0, Survival:0, Gathering:0, Crafting:0, Combat:0, Lore:0, Social:0 },
        quests: { done: 0, active: [] },
        discovered: { biomes: {}, ruins: {} },
        meta: { lastTick: Date.now() },
        _kit: false
      };
    }

    function persistLocalDebounced(){
      clearTimeout(persistLocalDebounced._t);
      persistLocalDebounced._t = setTimeout(()=> saveLocal(me.pub, local), 200);
    }

    function addXp(skill, amount){
      const mult = (LIFESTYLES[me.lifestyle]?.mult?.[skill] ?? 1.0);
      local.skills[skill] = (local.skills[skill] || 0) + Math.round(amount * mult);
    }

    // Translation helpers for game nouns
    function trBiome(b){ return t("names.biomes."+b); }
    function trMonster(k){ return t("names.monsters."+k); }
    function trItemName(k){ return t("names.items."+k) || k; }

    // Quests
    function generateQuests(){
      const base = seedU32FromStr(`quests:${roomId}:${me.pub}:${local.quests.done}`);
      const qs = [];
      qs.push({ id:`QEXP-${base}`, title:t("quest.cartoTitle"), desc:t("quest.cartoDesc",{n:4}), kind:"EXPLORE_BIOMES", need:4, prog:0, reward:{ berry:2, fiber:1 } });
      qs.push({ id:`QGAT-${base^0x1234}`, title:t("quest.gatherTitle"), desc:t("quest.gatherDesc",{n:12}), kind:"GATHER", need:12, prog:0, reward:{ wood:2, stone:1 } });
      qs.push({ id:`QKILL-${base^0xBEEF}`, title:t("quest.valorTitle"), desc:t("quest.valorDesc",{n:4}), kind:"DEFEAT", need:4, prog:0, reward:{ hide:2, berry:1 } });

      const pick = base % 3;
      qs.push(pick===0
        ? { id:`QSHR-${base^0xCAFE}`, title:t("quest.shrineTitle"), desc:t("quest.shrineDesc",{n:1}), kind:"CLAIM_SHRINE", need:1, prog:0, reward:{ shard:1, ore:1 } }
        : pick===1
          ? { id:`QWBN-${base^0xCAFE}`, title:t("quest.benchTitle"), desc:t("quest.benchDesc"), kind:"PLACE_WORKBENCH", need:1, prog:0, reward:{ ore:1, fiber:1 } }
          : { id:`QTL-${base^0xCAFE}`, title:t("quest.toolTitle"), desc:t("quest.toolDesc"), kind:"CRAFT_TOOL", need:1, prog:0, reward:{ wood:2, stone:1 } }
      );

      local.quests.active = qs;
      persistLocalDebounced();
    }

    function questProgress(kind, amount=1){
      for (const q of local.quests.active){
        if (q.kind !== kind) continue;
        q.prog = clamp(q.prog + amount, 0, q.need);
      }
      checkQuestComplete();
    }

    function checkQuestComplete(){
      let completedAny = false;
      for (const q of local.quests.active){
        if (q.prog >= q.need && !q._done){
          q._done = true;
          completedAny = true;
          for (const [k,v] of Object.entries(q.reward || {})){
            if (local.mats[k] != null) local.mats[k] += v;
          }
          toast(`${t("btn.quests")}: ${q.title}`);
        }
      }
      if (completedAny){
        local.quests.done += 1;
        generateQuests();
      }
      persistLocalDebounced();
      refreshHud();
    }

    // Signed events
    async function createSignedEvent(type, payload){
      const st = getAuthorState(me.pub);
      const body = { v:1, room:roomId, type, author:me.pub, seq:st.seq+1, prev:st.headId, time:Date.now(), payload };
      const bodyStr = stableStringify(body);
      const msgU8 = te.encode(bodyStr);
      const sigU8 = nacl.sign.detached(msgU8, me.secretKey);
      const sigB64 = toBase64(sigU8);
      const id = hashHexFromBodyAndSig(bodyStr, sigU8);
      return { ...body, sig:sigB64, id };
    }

    async function minePow(shrineId, bits, cancelRef){
      let nonce = 0;
      while (true){
        if (cancelRef.cancel) throw new Error("cancel");
        const h = powHashHex(shrineId, me.pub, String(nonce));
        if (meetsPowBits(h, bits)) return { nonce: String(nonce), hash: h };
        nonce++;
        if (nonce % 650 === 0) await new Promise(requestAnimationFrame);
      }
    }

    function publishEvent(ev){
      const v = verifyEventBasic(ev);
      if (!v.ok){ toast("Event invalid"); return; }
      const ok = appendEventToLedger(ev);
      if (!ok){ toast("Event out-of-order"); return; }
      saveLedgerDebounced();
      rebuildLedgerIndexes();
      repaintVisible();
      refreshHud();
      if (net.enabled) sendEv(ev);
    }

    // Phaser (isometric)
    const TILE_W = 64, TILE_H = 32, VIEW_W = 19, VIEW_H = 19;

    function isoToScreenTop(tx, ty){
      return { x: (tx - ty) * (TILE_W / 2), y: (tx + ty) * (TILE_H / 2) };
    }

    const touch = { up:false, down:false, left:false, right:false };
    function bindPad(id, setFn){
      const b = document.getElementById(id);
      b.addEventListener("pointerdown", ()=> setFn(true));
      b.addEventListener("pointerup", ()=> setFn(false));
      b.addEventListener("pointerout", ()=> setFn(false));
      b.addEventListener("pointercancel", ()=> setFn(false));
    }
    bindPad("btnUp",   v => touch.up = v);
    bindPad("btnDown", v => touch.down = v);
    bindPad("btnLeft", v => touch.left = v);
    bindPad("btnRight",v => touch.right = v);

    function getMoveDir(keys){
      const up    = keys.UP.isDown   || keys.W.isDown || touch.up;
      const down  = keys.DOWN.isDown || keys.S.isDown || touch.down;
      const left  = keys.LEFT.isDown || keys.A.isDown || touch.left;
      const right = keys.RIGHT.isDown|| keys.D.isDown || touch.right;

      let dx=0, dy=0;
      if (up)    { dx -= 1; dy -= 1; }
      if (down)  { dx += 1; dy += 1; }
      if (left)  { dx -= 1; dy += 1; }
      if (right) { dx += 1; dy -= 1; }
      if (dx !== 0 && dy !== 0) return {dx,dy};
      if (dx !== 0) return {dx,dy:0};
      if (dy !== 0) return {dx:0,dy};
      return {dx:0,dy:0};
    }

    function makeDiamondTexture(scene, key, w, h, fill){
      const g = scene.make.graphics({x:0,y:0,add:false});
      g.fillStyle(fill, 1);
      g.lineStyle(2, 0x000000, 0.25);
      g.beginPath();
      g.moveTo(w/2, 0); g.lineTo(w, h/2); g.lineTo(w/2, h); g.lineTo(0, h/2);
      g.closePath();
      g.fillPath(); g.strokePath();
      g.generateTexture(key, w, h);
      g.destroy();
    }
    function makeRectTexture(scene, key, w, h, fill){
      const g = scene.make.graphics({x:0,y:0,add:false});
      g.fillStyle(fill, 1);
      g.fillRoundedRect(0, 0, w, h, 7);
      g.lineStyle(2, 0x000000, 0.25);
      g.strokeRoundedRect(0, 0, w, h, 7);
      g.generateTexture(key, w, h);
      g.destroy();
    }
    function makeIcon(scene, key, w, h, fill, stroke=0x000000){
      const g = scene.make.graphics({x:0,y:0,add:false});
      g.fillStyle(fill, 1);
      g.lineStyle(2, stroke, 0.35);
      g.fillRoundedRect(0,0,w,h,8);
      g.strokeRoundedRect(0,0,w,h,8);
      g.lineStyle(2, 0xffffff, 0.5);
      g.beginPath();
      g.moveTo(w*0.20,h*0.58); g.lineTo(w*0.50,h*0.22); g.lineTo(w*0.80,h*0.58); g.lineTo(w*0.50,h*0.82);
      g.closePath();
      g.strokePath();
      g.generateTexture(key,w,h);
      g.destroy();
    }

    let gameScene = null;
    let tileSprites = [];
    let decorSprites = [];
    let worldObjectSprites = new Map();
    let remotePlayers = new Map();
    let centerTile = { x: 0, y: 0 };
    let lastMoveAt = 0;
    let stepCount = 0;

    const monsters = new Map();
    function monsterId(tx,ty,step){ return `m:${tx}:${ty}:${step}`; }

    function isNight(){
      const t0 = Math.floor(Date.now()/1000);
      const cycle = 240;
      const phase = (t0 % cycle) / cycle;
      return (phase > 0.62 || phase < 0.10);
    }

    function nightAlpha(){
      const t0 = Math.floor(Date.now()/1000);
      const cycle = 240;
      const phase = (t0 % cycle) / cycle;
      const d = Math.sin((phase * Math.PI * 2) - Math.PI/2);
      const base = clamp((d + 1) / 2, 0, 1);
      let a = base * 0.55;
      if (local?.equip?.accessory === "Lantern") a *= 0.55;
      return a;
    }

    class Main extends Phaser.Scene {
      constructor(){ super("Main"); }
      create(){
        gameScene = this;

        makeDiamondTexture(this, "t_grass", TILE_W, TILE_H, 0x2ecc71);
        makeDiamondTexture(this, "t_forest",TILE_W, TILE_H, 0x1e9b4f);
        makeDiamondTexture(this, "t_stone", TILE_W, TILE_H, 0x95a5a6);
        makeDiamondTexture(this, "t_sand",  TILE_W, TILE_H, 0xe4c36a);
        makeDiamondTexture(this, "t_swamp", TILE_W, TILE_H, 0x7d5aa6);
        makeDiamondTexture(this, "t_snow",  TILE_W, TILE_H, 0xdfe8f2);
        makeDiamondTexture(this, "t_water", TILE_W, TILE_H, 0x4aa3ff);
        makeDiamondTexture(this, "t_mount", TILE_W, TILE_H, 0x8b6b4f);

        makeRectTexture(this, "p_me",    26, 38, 0xf1c40f);
        makeRectTexture(this, "p_other", 26, 38, 0x4aa3ff);

        makeRectTexture(this, "m_slime", 22, 22, 0xff5c5c);
        makeRectTexture(this, "m_wolf",  22, 22, 0xc2c2c2);
        makeRectTexture(this, "m_bandit",22, 22, 0xffb703);
        makeRectTexture(this, "m_wisp",  22, 22, 0xffffff);

        makeIcon(this, "d_tree",  22, 30, 0x2ecc71);
        makeIcon(this, "d_rock",  26, 22, 0x95a5a6);
        makeIcon(this, "d_bush",  22, 22, 0xe67e22);
        makeIcon(this, "d_ore",   26, 22, 0xadb5bd);
        makeIcon(this, "d_herb",  22, 22, 0x90be6d);
        makeIcon(this, "d_bones", 26, 22, 0xf8f9fa);
        makeIcon(this, "d_ruins", 26, 30, 0x8d99ae);
        makeIcon(this, "d_shrine",22, 34, 0xffffff);

        makeIcon(this, "o_fire",  26, 26, 0xffd166);
        makeIcon(this, "o_sign",  26, 26, 0xb08968);
        makeIcon(this, "o_bench", 26, 26, 0x9b5de5);

        tileSprites = [];
        decorSprites = [];
        for (let i=0; i<VIEW_W*VIEW_H; i++){
          const t0 = this.add.image(0,0,"t_grass").setOrigin(0.5,0);
          tileSprites.push(t0);
          const d0 = this.add.image(0,0,"d_tree").setOrigin(0.5,1);
          d0.setVisible(false);
          decorSprites.push(d0);
        }

        this.playerSprite = this.add.sprite(0,0,"p_me").setOrigin(0.5,1);
        this.cameras.main.startFollow(this.playerSprite, true, 0.14, 0.14);

        this.dark = this.add.rectangle(0,0,this.scale.width,this.scale.height,0x000000,0).setOrigin(0).setScrollFactor(0).setDepth(999999);
        this.scale.on("resize", (s)=>{ this.dark.width = s.width; this.dark.height = s.height; });

        this.keys = this.input.keyboard.addKeys("W,A,S,D,UP,DOWN,LEFT,RIGHT,E,SPACE,ENTER");

        this.input.on("pointerdown", (p)=>{ if (p.downY < 90) return; doAction(); });

        centerTile.x = Math.round(local.player.x);
        centerTile.y = Math.round(local.player.y);
        syncLocalPlayerSprite();
        repaintVisible();
        refreshHud();
      }

      update(time, delta){
        const dt = delta/1000;
        tickSurvival(dt);
        this.dark.setAlpha(nightAlpha());

        const dir = getMoveDir(this.keys);
        const wt = calcWeight(local.mats), cap = calcCapacity();
        const over = wt > cap;
        const baseCd = local.stats.stamina <= 0 ? 270 : 120;
        const moveCooldown = over ? baseCd + 70 : baseCd;

        if ((dir.dx !== 0 || dir.dy !== 0) && time - lastMoveAt > moveCooldown){
          attemptMove(dir.dx, dir.dy);
          lastMoveAt = time;
        }

        if (Phaser.Input.Keyboard.JustDown(this.keys.E)) doAction();
        if (Phaser.Input.Keyboard.JustDown(this.keys.SPACE)) doAttack();

        tickMonsters(time);

        const cx = Math.round(local.player.x);
        const cy = Math.round(local.player.y);
        if (cx !== centerTile.x || cy !== centerTile.y){
          centerTile.x = cx; centerTile.y = cy;
          repaintVisible();
        }

        for (const rp of remotePlayers.values()){
          if (!rp.sprite) continue;
          const p = isoToScreenTop(rp.x, rp.y);
          rp.sprite.x = p.x;
          rp.sprite.y = p.y + TILE_H/2;
          rp.sprite.setDepth(rp.sprite.y);
          if (rp.bubble){
            rp.bubble.x = rp.sprite.x;
            rp.bubble.y = rp.sprite.y - 48;
            rp.bubble.setDepth(rp.sprite.y + 1);
          }
        }
      }
    }

    function repaintVisible(){
      if (!gameScene) return;
      for (const spr of worldObjectSprites.values()) spr.destroy();
      worldObjectSprites.clear();

      const halfW = Math.floor(VIEW_W/2);
      const halfH = Math.floor(VIEW_H/2);

      let idx = 0;
      for (let j=0; j<VIEW_H; j++){
        for (let i=0; i<VIEW_W; i++){
          const tx = centerTile.x + (i - halfW);
          const ty = centerTile.y + (j - halfH);

          const b = biomeAt(tx, ty);
          const tile = tileSprites[idx];
          const deco = decorSprites[idx];
          idx++;

          const p = isoToScreenTop(tx, ty);
          tile.setTexture(tileKeyFromBiome(b));
          tile.x = p.x;
          tile.y = p.y;
          tile.tx = tx; tile.ty = ty;
          tile.setDepth(tile.y);

          const s = shrineAt(tx, ty, b);
          const claimed = s && ledger.shrineClaims.has(s.shrineId);

          if (s && !claimed){
            deco.setTexture("d_shrine");
            deco.setVisible(true);
            deco.x = p.x; deco.y = p.y + TILE_H/2 + 18;
          } else {
            const d = decorAt(tx, ty, b);
            if (d === "Tree"){ deco.setTexture("d_tree"); deco.setVisible(true); }
            else if (d === "Rock"){ deco.setTexture("d_rock"); deco.setVisible(true); }
            else if (d === "Bush"){ deco.setTexture("d_bush"); deco.setVisible(true); }
            else if (d === "Ore"){ deco.setTexture("d_ore"); deco.setVisible(true); }
            else if (d === "Herb"){ deco.setTexture("d_herb"); deco.setVisible(true); }
            else if (d === "Bones"){ deco.setTexture("d_bones"); deco.setVisible(true); }
            else if (d === "Ruins"){ deco.setTexture("d_ruins"); deco.setVisible(true); }
            else deco.setVisible(false);

            if (deco.visible){ deco.x = p.x; deco.y = p.y + TILE_H/2 + 18; }
          }
          deco.setDepth(tile.y + TILE_H + 10);

          const objs = (ledger.objectsByPos.get(`${tx},${ty}`) || []).filter(o=>o && !o.removed);
          for (const obj of objs){
            const icon = obj.kind === "Campfire" ? "o_fire" : obj.kind === "Workbench" ? "o_bench" : "o_sign";
            const spr = gameScene.add.image(p.x, p.y + TILE_H/2 + 18, icon).setOrigin(0.5,1);
            spr.setDepth(tile.y + TILE_H + 12);
            spr._obj = obj;
            worldObjectSprites.set(`${obj.kind}:${obj.ownerPub}:${obj.x}:${obj.y}:${obj.text}`, spr);
          }
        }
      }

      syncLocalPlayerSprite();
      refreshHud();
    }

    function syncLocalPlayerSprite(){
      if (!gameScene) return;
      const p = isoToScreenTop(local.player.x, local.player.y);
      gameScene.playerSprite.x = p.x;
      gameScene.playerSprite.y = p.y + TILE_H/2;
      gameScene.playerSprite.setDepth(gameScene.playerSprite.y);
    }

    function getObjectsAt(tx,ty){
      return (ledger.objectsByPos.get(`${tx},${ty}`) || []).filter(o=>o && !o.removed);
    }

    function isNearWorkbench(tx,ty){
      for (let dy=-1; dy<=1; dy++){
        for (let dx=-1; dx<=1; dx++){
          const objs = getObjectsAt(tx+dx, ty+dy);
          if (objs.some(o=> o.kind === "Workbench")) return true;
        }
      }
      return false;
    }

    function currentContext(){
      const tx = local.player.x|0;
      const ty = local.player.y|0;
      const b = biomeAt(tx,ty);
      const deco = decorAt(tx,ty,b);
      const shrine = shrineAt(tx,ty,b);
      const shrineClaimed = shrine && ledger.shrineClaims.has(shrine.shrineId);
      const objs = getObjectsAt(tx,ty);
      const objHere = objs.length ? objs[0] : null;
      return { tx, ty, b, deco, shrine, shrineClaimed, objHere, nearWorkbench: isNearWorkbench(tx,ty) };
    }

    let mining = { active:false, cancel:false };

    async function doAction(){
      if (!gameScene) return;
      const c = currentContext();

      if (mining.active){ mining.cancel = true; return; }

      if (c.shrine && !c.shrineClaimed){
        mining.active = true; mining.cancel = false;
        const bits = 16;
        toast(t("toast.mining"), 1600);
        try{
          const pow = await minePow(c.shrine.shrineId, bits, mining);
          const ev = await createSignedEvent("CLAIM_SHRINE", { shrineId:c.shrine.shrineId, x:c.tx, y:c.ty, powBits:bits, powNonce:pow.nonce, powHash:pow.hash });
          publishEvent(ev);
          questProgress("CLAIM_SHRINE", 1);
          toast(t("toast.shrineClaimed"));
        } catch {
          toast(t("toast.miningCancelled"));
        } finally {
          mining.active = false;
          persistLocalDebounced();
          rebuildLedgerIndexes();
          repaintVisible();
          refreshHud();
        }
        return;
      }

      if (c.objHere?.kind === "Campfire"){
        local.stats.stamina = 100;
        local.stats.hp = clamp(local.stats.hp + 30, 0, 100);
        local.stats.hunger = clamp(local.stats.hunger - 18, 0, 100);
        addXp("Survival", 20);
        toast(t("toast.rest"));
        persistLocalDebounced(); refreshHud();
        return;
      }

      if (c.objHere?.kind === "Workbench"){
        openCraft(true);
        return;
      }

      if (c.objHere?.kind === "Signpost"){
        const owner = ledger.profiles.get(c.objHere.ownerPub)?.name || c.objHere.ownerPub.slice(0,8);
        showModal(t("modal.sign"), `
          <div class="card">
            <div class="muted">${escapeHtml(t("modal.author"))}: <b>${escapeHtml(owner)}</b> <span class="mono">(${c.objHere.ownerPub.slice(0,10)}‚Ä¶)</span></div>
            <p style="white-space:pre-wrap;margin:8px 0 0 0">${escapeHtml(c.objHere.text || "(empty)")}</p>
          </div>
          ${c.objHere.ownerPub === me.pub ? `<div style="margin-top:10px"><button id="rmSign">${escapeHtml(t("modal.removeMine"))}</button></div>` : ``}
        `);
        setTimeout(()=>{
          const rm = document.getElementById("rmSign");
          if (rm) rm.onclick = async ()=>{
            const obj = c.objHere;
            let objectId = null;
            for (const [id,o] of ledger.objects.entries()){
              if (!o || o.removed) continue;
              if (o.ownerPub === obj.ownerPub && o.kind === obj.kind && o.x === obj.x && o.y === obj.y && o.text === obj.text){
                objectId = id; break;
              }
            }
            if (!objectId) return;
            const ev = await createSignedEvent("REMOVE_OBJECT", { objectId });
            publishEvent(ev);
            modal.style.display = "none";
          };
        },0);
        return;
      }

      const tool = local.equip.tool;

      if (c.deco === "Ruins"){
        const key = `${c.tx},${c.ty}`;
        if (local.discovered.ruins[key]){
          toast(t("toast.ruinsAlready"));
          return;
        }
        local.discovered.ruins[key] = true;
        const lootShard = (Math.random() < 0.55) ? 1 : 0;
        const lootOre = 1 + (Math.random() < 0.35 ? 1 : 0);
        const lootHide = (Math.random() < 0.30) ? 1 : 0;

        local.mats.ore += lootOre;
        local.mats.shard += lootShard;
        local.mats.hide += lootHide;
        addXp("Lore", 18);
        addXp("Survival", 10);
        questProgress("GATHER", 2);

        const lootTxt = `‚õì+${lootOre}${lootShard?` ‚úß+${lootShard}`:""}${lootHide?` üêæ+${lootHide}`:""}`;
        toast(t("toast.ruinsLoot",{loot:lootTxt}), 1600);

        persistLocalDebounced(); refreshHud();
        return;
      }

      if (c.deco === "Tree"){
        let gain = 1 + (Math.random() < 0.30 ? 1 : 0);
        if (tool === "Axe") gain += 1;
        local.mats.wood += gain;
        addXp("Gathering", 18);
        questProgress("GATHER", 1);
        toast(`ü™µ +${gain}`);
      } else if (c.deco === "Rock"){
        let gain = 1 + (Math.random() < 0.25 ? 1 : 0);
        if (tool === "Pickaxe") gain += 1;
        local.mats.stone += gain;
        addXp("Gathering", 18);
        questProgress("GATHER", 1);
        toast(`‚õè +${gain}`);
      } else if (c.deco === "Ore"){
        if (tool !== "Pickaxe"){
          toast(t("toast.needPickaxe"));
          return;
        }
        let gain = 1 + (Math.random() < 0.35 ? 1 : 0);
        local.mats.ore += gain;
        if (Math.random() < 0.08) local.mats.shard += 1;
        addXp("Gathering", 22);
        questProgress("GATHER", 1);
        toast(`‚õì +${gain}${(Math.random()<0.08)?" ‚úß+1":""}`, 1200);
      } else if (c.deco === "Herb"){
        let gain = 1 + (Math.random() < 0.40 ? 1 : 0);
        local.mats.fiber += gain;
        addXp("Survival", 10);
        addXp("Gathering", 10);
        questProgress("GATHER", 1);
        toast(`üßµ +${gain}`);
      } else if (c.deco === "Bones"){
        local.mats.hide += 1;
        addXp("Survival", 12);
        questProgress("GATHER", 1);
        toast(`üêæ +1`);
      } else if (c.deco === "Bush"){
        let gain = 1 + (Math.random() < 0.30 ? 1 : 0);
        local.mats.berry += gain;
        local.stats.hunger = clamp(local.stats.hunger - 9, 0, 100);
        addXp("Survival", 10);
        questProgress("GATHER", 1);
        toast(`üçì +${gain}`);
      } else {
        toast(t("toast.nothing"));
        return;
      }

      persistLocalDebounced();
      refreshHud();
    }

    function weaponBonus(){
      const w = local.equip.weapon;
      if (w === "Spear") return 4;
      if (w === "Sword") return 6;
      return 0;
    }

    function armorBonus(){
      const a = local.equip.armor;
      if (a === "Cloak") return { hungerReduce: 0.18, dmgReduce: 0.05 };
      if (a === "Leather") return { hungerReduce: 0.0, dmgReduce: 0.12 };
      return { hungerReduce: 0.0, dmgReduce: 0.0 };
    }

    function doAttack(){
      const px = local.player.x|0, py = local.player.y|0;

      let targetId = null;
      let bestDist = 999;
      for (const [id, m] of monsters.entries()){
        const dist = Math.abs(m.x - px) + Math.abs(m.y - py);
        if (dist <= 1 && dist < bestDist){
          bestDist = dist;
          targetId = id;
        }
      }
      if (!targetId){ toast(t("toast.noEnemies")); return; }

      const combatLv = skillLevel(local.skills.Combat || 0);
      const dmg = 6 + combatLv*2 + weaponBonus();

      const m = monsters.get(targetId);
      m.hp -= dmg;
      addXp("Combat", 18);

      toast(t("toast.hit",{dmg}));

      if (m.hp <= 0){
        m.sprite.destroy();
        monsters.delete(targetId);

        const drop = m.drop || {};
        for (const [k,v] of Object.entries(drop)){
          local.mats[k] = (local.mats[k]||0) + v;
        }
        if (Math.random() < 0.22) local.mats.berry += 1;

        questProgress("DEFEAT", 1);
        toast(t("toast.enemyDefeated",{loot:fmtLoot(drop)}), 1500);
      }

      persistLocalDebounced();
      refreshHud();
    }

    function fmtLoot(d){
      const parts = [];
      if (d.hide) parts.push(`üêæx${d.hide}`);
      if (d.ore) parts.push(`‚õìx${d.ore}`);
      if (d.wood) parts.push(`ü™µx${d.wood}`);
      if (d.shard) parts.push(`‚úßx${d.shard}`);
      return parts.length ? parts.join(" ") : "(small loot)";
    }

    function monsterData(kind){
      if (kind === "Wolf") return { tex:"m_wolf", hp: 22, atk: 6, ms: 520, drop:{ hide: 1 + (Math.random()<0.45?1:0) } };
      if (kind === "Bandit") return { tex:"m_bandit", hp: 26, atk: 7, ms: 560, drop:{ ore: (Math.random()<0.55?1:0), wood: (Math.random()<0.35?1:0) } };
      if (kind === "Wisp") return { tex:"m_wisp", hp: 18, atk: 5, ms: 480, drop:{ shard: (Math.random()<0.45?1:0) } };
      return { tex:"m_slime", hp: 20, atk: 5, ms: 600, drop:{ } };
    }

    function maybeSpawnMonster(){
      const tx = local.player.x|0;
      const ty = local.player.y|0;
      const b = biomeAt(tx,ty);
      const r = hash2D01(worldSeedU32 ^ 0xDEADBEEF, tx, ty);

      let chance = 0.10;
      if (b === "Forest") chance = 0.15;
      if (b === "Swamp") chance = 0.16;
      if (b === "Mount") chance = 0.14;
      if (b === "Snow")  chance = 0.13;
      if (isNight()) chance *= 1.35;

      if (r < chance){
        const id = monsterId(tx,ty,stepCount);
        if (monsters.has(id) || !gameScene) return;

        const kind =
          (b === "Forest") ? "Wolf" :
          (b === "Swamp")  ? "Slime" :
          (b === "Snow")   ? "Wisp" :
          (b === "Sand")   ? "Bandit" :
          (b === "Mount" || b === "Stone") ? (Math.random()<0.6 ? "Bandit" : "Wisp") :
          "Slime";

        const data = monsterData(kind);
        const spawnX = tx + 1, spawnY = ty;

        const p = isoToScreenTop(spawnX, spawnY);
        const spr = gameScene.add.sprite(p.x, p.y + TILE_H/2, data.tex).setOrigin(0.5,1);
        spr.setDepth(spr.y);

        monsters.set(id, { kind, x:spawnX, y:spawnY, hp:data.hp, atk:data.atk, ms:data.ms, drop:data.drop, sprite:spr, nextMove:0, hitAt:0 });
        toast(t("toast.spawned",{monster: trMonster(kind)}));
      }
    }

    function tickMonsters(time){
      if (!gameScene) return;
      for (const [id, m] of monsters.entries()){
        if (!m.sprite) continue;

        if (time >= (m.nextMove||0)){
          m.nextMove = time + m.ms;
          const dx = clamp((local.player.x|0) - m.x, -1, 1);
          const dy = clamp((local.player.y|0) - m.y, -1, 1);
          const nx = m.x + dx, ny = m.y + dy;
          if (biomeAt(nx, ny) !== "Water"){ m.x = nx; m.y = ny; }
        }

        const dist = Math.abs(m.x - (local.player.x|0)) + Math.abs(m.y - (local.player.y|0));
        if (dist === 0 && time >= (m.hitAt||0)){
          m.hitAt = time + 720;
          const armor = armorBonus();
          const dmg = Math.max(1, Math.round(m.atk * (1 - armor.dmgReduce)));
          local.stats.hp = clamp(local.stats.hp - dmg, 0, 100);
          persistLocalDebounced();
        }

        const p = isoToScreenTop(m.x, m.y);
        m.sprite.x = p.x;
        m.sprite.y = p.y + TILE_H/2;
        m.sprite.setDepth(m.sprite.y);
      }
      refreshHud();
    }

    function attemptMove(dx, dy){
      const nx = (local.player.x|0) + dx;
      const ny = (local.player.y|0) + dy;

      const b = biomeAt(nx, ny);
      if (b === "Water"){ toast(t("toast.deepWater")); return; }

      let cost = 2;
      if (b === "Swamp") cost = 4;
      if (b === "Sand") cost = 3;
      if (b === "Mount") cost = 5;
      if (b === "Snow") cost = 4;

      const wt = calcWeight(local.mats);
      const cap = calcCapacity();
      if (wt > cap) cost += 1;

      const ath = skillLevel(local.skills.Athletics || 0);
      cost = Math.max(1, cost - Math.floor(ath / 2));

      local.player.x = nx;
      local.player.y = ny;
      local.stats.stamina = clamp(local.stats.stamina - cost, 0, 100);

      const surv = skillLevel(local.skills.Survival || 0);
      const armor = armorBonus();
      const hungerInc = Math.max(0.22, (isNight()?0.70:0.55) - surv * 0.06) * (1 - armor.hungerReduce);
      local.stats.hunger = clamp(local.stats.hunger + hungerInc, 0, 100);

      addXp("Athletics", 6);
      addXp("Survival", 3);

      if (!local.discovered.biomes[b]){
        local.discovered.biomes[b] = true;
        questProgress("EXPLORE_BIOMES", 1);
        toast(t("toast.newBiome",{biome: trBiome(b)}));
      }

      stepCount++;
      if (hash2D01(worldSeedU32 ^ 0x11111111, nx, ny) < 0.75) maybeSpawnMonster();

      if (net.enabled) sendMove({ pub: me.pub, x: nx, y: ny, name: me.name, life: me.lifestyle });

      syncLocalPlayerSprite();
      persistLocalDebounced();
      refreshHud();
    }

    function tickSurvival(dt){
      const wt = calcWeight(local.mats);
      const cap = calcCapacity();
      const over = wt > cap;

      const stRegen = over ? 0.6 : 1.2;
      local.stats.stamina = clamp(local.stats.stamina + dt*stRegen, 0, 100);

      if (local.stats.hunger > 85){
        local.stats.hp = clamp(local.stats.hp - dt*2.8, 0, 100);
      }
      if (isNight() && local.stats.hunger > 60){
        local.stats.hp = clamp(local.stats.hp - dt*0.6, 0, 100);
      }

      if (local.stats.hp <= 0){
        local.stats.hp = 100;
        local.stats.stamina = 60;
        local.stats.hunger = 40;
        local.player.x = 0;
        local.player.y = 0;
        toast(t("toast.youFell"), 1600);
        syncLocalPlayerSprite();
        repaintVisible();
        persistLocalDebounced();
      }
    }

    // UI panels
    function iconFor(k){
      return ({ wood:"ü™µ", stone:"‚õè", ore:"‚õì", fiber:"üßµ", hide:"üêæ", shard:"‚úß", berry:"üçì" })[k] || k;
    }
    function fmtReward(r){
      if (!r) return "(none)";
      const parts = [];
      for (const k of ["wood","stone","ore","fiber","hide","shard","berry"]){
        if (r[k]) parts.push(`${iconFor(k)} x${r[k]}`);
      }
      return parts.join(" ");
    }

    function openQuests(){
      const rows = local.quests.active.map(q => `
        <div class="card">
          <b>${escapeHtml(q.title)}</b>
          <div class="muted">${escapeHtml(q.desc)}</div>
          <div style="margin-top:6px">${escapeHtml(t("common.progress"))}: <b>${q.prog}/${q.need}</b> ${q._done?`<span class="muted">(${escapeHtml(t("common.completed"))})</span>`:""}</div>
          <div class="muted" style="margin-top:6px">${escapeHtml(t("common.reward"))}: ${fmtReward(q.reward)}</div>
        </div>
      `).join("");
      showModal(t("modal.quests"), `<div class="grid2">${rows}</div>`);
    }

    function openSkills(){
      const sk = local.skills;
      const items = Object.keys(sk).map(k=>{
        const xp = sk[k]||0;
        const lv = skillLevel(xp);
        return `<li><b>${escapeHtml(k)}</b>: lvl <b>${lv}</b> <span class="muted">(xp ${xp})</span></li>`;
      }).join("");

      const eq = local.equip;
      showModal(t("modal.skills"), `
        <div class="grid2">
          <div class="card">
            <b>${escapeHtml(t("btn.skills"))}</b>
            <ul style="margin:8px 0 0 18px">${items}</ul>
          </div>
          <div class="card">
            <b>${escapeHtml(t("login.lifestyleLabel"))}: ${escapeHtml(t("life."+me.lifestyle))}</b>
            <div class="muted" style="margin-top:10px">${escapeHtml(t("modal.currentEquip"))}</div>
            <ul style="margin:8px 0 0 18px">
              <li>Tool: <b>${escapeHtml(eq.tool ? trItemName(eq.tool) : "‚Äî")}</b></li>
              <li>Weapon: <b>${escapeHtml(eq.weapon ? trItemName(eq.weapon) : "‚Äî")}</b></li>
              <li>Armor: <b>${escapeHtml(eq.armor ? trItemName(eq.armor) : "‚Äî")}</b></li>
              <li>Accessory: <b>${escapeHtml(eq.accessory ? trItemName(eq.accessory) : "‚Äî")}</b></li>
            </ul>
          </div>
        </div>
      `);
    }

    function openWorld(){
      const list = [...ledger.score.entries()]
        .sort((a,b)=> (b[1]-a[1]) || String(a[0]).localeCompare(String(b[0])))
        .slice(0, 20)
        .map(([pub, wins])=>{
          const name = ledger.profiles.get(pub)?.name || pub.slice(0,8);
          return `<li><b>${escapeHtml(name)}</b> ‚Äî ${wins}</li>`;
        }).join("") || `<li class="muted">(empty)</li>`;

      const totalObj = [...ledger.objects.values()].filter(o=>o && !o.removed).length;
      const totalShr = ledger.shrineClaims.size;

      showModal(t("modal.world"), `
        <div class="grid2">
          <div class="card">
            <b>${escapeHtml(t("modal.summary"))}</b>
            <ul style="margin:8px 0 0 18px">
              <li>Objects: <b>${totalObj}</b></li>
              <li>Shrines: <b>${totalShr}</b></li>
              <li>Authors: <b>${Object.keys(ledger.raw.authors||{}).length}</b></li>
            </ul>
            <p class="muted" style="margin-top:10px">${escapeHtml(t("modal.tip"))}</p>
          </div>
          <div class="card">
            <b>${escapeHtml(t("modal.ranking"))}</b>
            <ol style="margin:8px 0 0 18px">${list}</ol>
          </div>
        </div>
      `);
    }

    function openCredits(){
      showModal(t("modal.credits"), `
        <div class="card">
          <ul style="margin:8px 0 0 18px">
            <li><b>Phaser</b> ‚Äî MIT</li>
            <li><b>Trystero</b> ‚Äî MIT</li>
            <li><b>tweetnacl</b> ‚Äî Ed25519</li>
            <li><b>@noble/hashes</b> ‚Äî MIT</li>
            <li><b>Flags</b> ‚Äî Twemoji via jsDelivr + Senyera via Wikimedia</li>
          </ul>
        </div>
        <div class="card" style="margin-top:10px">
          <b>Assets</b>
          <p class="muted" style="margin:6px 0 0 0">
            This demo uses code-generated placeholders. When you add CC0 packs (e.g., Kenney), list pack names here.
          </p>
        </div>
      `);
    }

    function openCraft(){
      const c = currentContext();
      const canPlaceHere = (biomeAt(c.tx,c.ty) !== "Water");
      const hasBench = c.nearWorkbench;

      const eq = local.equip;
      showModal(t("modal.craft"), `
        <div class="grid2">
          <div class="card">
            <b>${escapeHtml(t("modal.recipesBasic"))}</b>
            <ul style="margin:8px 0 0 18px">
              <li><button id="mkAxe">${escapeHtml(trItemName("Axe"))}</button> <span class="muted">cost: ü™µ2 ‚õè1</span></li>
              <li><button id="mkPick">${escapeHtml(trItemName("Pickaxe"))}</button> <span class="muted">cost: ü™µ2 ‚õè2</span></li>
              <li><button id="mkFire">${escapeHtml(trItemName("Campfire"))}</button> <span class="muted">cost: ü™µ2 ‚õè1</span></li>
              <li><button id="mkBench">${escapeHtml(trItemName("Workbench"))}</button> <span class="muted">cost: ü™µ4 ‚õè2</span></li>
              <li><button id="mkSign">${escapeHtml(trItemName("Signpost"))}</button> <span class="muted">cost: ü™µ1</span></li>
              <li><button id="eatB">üçì</button> <span class="muted">cost: üçì1</span></li>
            </ul>

            <div class="muted" style="margin-top:10px">${escapeHtml(t("modal.recipesAdv"))}: ${hasBench ? "‚úÖ" : "‚ùå"}</div>
            <ul style="margin:8px 0 0 18px">
              <li><button id="mkSpear">${escapeHtml(trItemName("Spear"))}</button> <span class="muted">cost: ü™µ2 üêæ1</span></li>
              <li><button id="mkSword">${escapeHtml(trItemName("Sword"))}</button> <span class="muted">cost: ‚õì3 ü™µ1</span></li>
              <li><button id="mkCloak">${escapeHtml(trItemName("Cloak"))}</button> <span class="muted">cost: üßµ3 üêæ1</span></li>
              <li><button id="mkLeather">${escapeHtml(trItemName("Leather"))}</button> <span class="muted">cost: üêæ3</span></li>
              <li><button id="mkLantern">${escapeHtml(trItemName("Lantern"))}</button> <span class="muted">cost: ‚úß1 ‚õì2</span></li>
            </ul>
          </div>

          <div class="card">
            <b>${escapeHtml(t("modal.materials"))}</b>
            <ul style="margin:8px 0 0 18px">
              <li>ü™µ ${local.mats.wood}</li>
              <li>‚õè ${local.mats.stone}</li>
              <li>‚õì ${local.mats.ore}</li>
              <li>üßµ ${local.mats.fiber}</li>
              <li>üêæ ${local.mats.hide}</li>
              <li>‚úß ${local.mats.shard}</li>
              <li>üçì ${local.mats.berry}</li>
            </ul>

            <div class="muted" style="margin-top:10px">${escapeHtml(t("modal.currentEquip"))}</div>
            <ul style="margin:8px 0 0 18px">
              <li>Tool: <b>${escapeHtml(eq.tool ? trItemName(eq.tool) : "‚Äî")}</b></li>
              <li>Weapon: <b>${escapeHtml(eq.weapon ? trItemName(eq.weapon) : "‚Äî")}</b></li>
              <li>Armor: <b>${escapeHtml(eq.armor ? trItemName(eq.armor) : "‚Äî")}</b></li>
              <li>Accessory: <b>${escapeHtml(eq.accessory ? trItemName(eq.accessory) : "‚Äî")}</b></li>
            </ul>

            <p class="muted" style="margin-top:10px">${escapeHtml(t("modal.position"))}: (${c.tx},${c.ty}) ‚Äî ${escapeHtml(trBiome(c.b))}</p>
          </div>
        </div>
      `);

      setTimeout(()=> wireCraftButtons(canPlaceHere, hasBench), 0);
    }

    async function wireCraftButtons(canPlaceHere, hasBench){
      const $ = (id)=> document.getElementById(id);

      function needMat(cond){ if (!cond){ toast(t("toast.notEnough")); return true; } return false; }
      function needBench(){ if (!hasBench){ toast(t("toast.benchNeeded")); return true; } return false; }

      $("mkAxe").onclick = ()=>{
        if (needMat(local.mats.wood >= 2 && local.mats.stone >= 1)) return;
        local.mats.wood -= 2; local.mats.stone -= 1;
        local.equip.tool = "Axe";
        addXp("Crafting", 35);
        questProgress("CRAFT_TOOL", 1);
        toast(t("toast.equipped",{item: trItemName("Axe")}));
        persistLocalDebounced(); refreshHud(); modal.style.display="none";
      };

      $("mkPick").onclick = ()=>{
        if (needMat(local.mats.wood >= 2 && local.mats.stone >= 2)) return;
        local.mats.wood -= 2; local.mats.stone -= 2;
        local.equip.tool = "Pickaxe";
        addXp("Crafting", 45);
        questProgress("CRAFT_TOOL", 1);
        toast(t("toast.equipped",{item: trItemName("Pickaxe")}));
        persistLocalDebounced(); refreshHud(); modal.style.display="none";
      };

      $("mkFire").onclick = async ()=>{
        if (!canPlaceHere){ toast(t("toast.deepWater")); return; }
        if (needMat(local.mats.wood >= 2 && local.mats.stone >= 1)) return;
        local.mats.wood -= 2; local.mats.stone -= 1;
        addXp("Crafting", 30);
        const c = currentContext();
        const objectId = bytesToHex(sha256(te.encode(`obj:${me.pub}:${Date.now()}:${Math.random()}`)));
        const ev = await createSignedEvent("PLACE_OBJECT", { objectId, kind:"Campfire", x:c.tx, y:c.ty, text:"" });
        publishEvent(ev);
        toast(t("toast.placedShared",{item: trItemName("Campfire")}));
        persistLocalDebounced(); modal.style.display="none";
      };

      $("mkBench").onclick = async ()=>{
        if (!canPlaceHere){ toast(t("toast.deepWater")); return; }
        if (needMat(local.mats.wood >= 4 && local.mats.stone >= 2)) return;
        local.mats.wood -= 4; local.mats.stone -= 2;
        addXp("Crafting", 55);
        const c = currentContext();
        const objectId = bytesToHex(sha256(te.encode(`obj:${me.pub}:${Date.now()}:${Math.random()}`)));
        const ev = await createSignedEvent("PLACE_OBJECT", { objectId, kind:"Workbench", x:c.tx, y:c.ty, text:"" });
        publishEvent(ev);
        questProgress("PLACE_WORKBENCH", 1);
        toast(t("toast.placedShared",{item: trItemName("Workbench")}));
        persistLocalDebounced(); modal.style.display="none";
      };

      $("mkSign").onclick = async ()=>{
        if (!canPlaceHere){ toast(t("toast.deepWater")); return; }
        if (needMat(local.mats.wood >= 1)) return;
        const text = prompt(t("prompt.signText"), t("prompt.signDefault"));
        if (text == null) return;
        local.mats.wood -= 1;
        addXp("Crafting", 25);
        addXp("Social", 12);
        const c = currentContext();
        const objectId = bytesToHex(sha256(te.encode(`obj:${me.pub}:${Date.now()}:${Math.random()}`)));
        const ev = await createSignedEvent("PLACE_OBJECT", { objectId, kind:"Signpost", x:c.tx, y:c.ty, text: String(text).slice(0,160) });
        publishEvent(ev);
        toast(t("toast.placedShared",{item: trItemName("Signpost")}));
        persistLocalDebounced(); modal.style.display="none";
      };

      $("eatB").onclick = ()=>{
        if (needMat(local.mats.berry >= 1)) return;
        local.mats.berry -= 1;
        local.stats.hunger = clamp(local.stats.hunger - 22, 0, 100);
        local.stats.hp = clamp(local.stats.hp + 10, 0, 100);
        addXp("Survival", 12);
        toast(t("toast.ateBerry"));
        persistLocalDebounced(); refreshHud();
      };

      $("mkSpear").onclick = ()=>{
        if (needBench()) return;
        if (needMat(local.mats.wood >= 2 && local.mats.hide >= 1)) return;
        local.mats.wood -= 2; local.mats.hide -= 1;
        local.equip.weapon = "Spear";
        addXp("Crafting", 40);
        toast(t("toast.equipped",{item: trItemName("Spear")}));
        persistLocalDebounced(); refreshHud(); modal.style.display="none";
      };

      $("mkSword").onclick = ()=>{
        if (needBench()) return;
        if (needMat(local.mats.ore >= 3 && local.mats.wood >= 1)) return;
        local.mats.ore -= 3; local.mats.wood -= 1;
        local.equip.weapon = "Sword";
        addXp("Crafting", 60);
        toast(t("toast.equipped",{item: trItemName("Sword")}));
        persistLocalDebounced(); refreshHud(); modal.style.display="none";
      };

      $("mkCloak").onclick = ()=>{
        if (needBench()) return;
        if (needMat(local.mats.fiber >= 3 && local.mats.hide >= 1)) return;
        local.mats.fiber -= 3; local.mats.hide -= 1;
        local.equip.armor = "Cloak";
        addXp("Crafting", 45);
        toast(t("toast.equipped",{item: trItemName("Cloak")}));
        persistLocalDebounced(); refreshHud(); modal.style.display="none";
      };

      $("mkLeather").onclick = ()=>{
        if (needBench()) return;
        if (needMat(local.mats.hide >= 3)) return;
        local.mats.hide -= 3;
        local.equip.armor = "Leather";
        addXp("Crafting", 55);
        toast(t("toast.equipped",{item: trItemName("Leather")}));
        persistLocalDebounced(); refreshHud(); modal.style.display="none";
      };

      $("mkLantern").onclick = ()=>{
        if (needBench()) return;
        if (needMat(local.mats.shard >= 1 && local.mats.ore >= 2)) return;
        local.mats.shard -= 1; local.mats.ore -= 2;
        local.equip.accessory = "Lantern";
        addXp("Lore", 25);
        addXp("Crafting", 35);
        toast(t("toast.equipped",{item: trItemName("Lantern")}));
        persistLocalDebounced(); refreshHud(); modal.style.display="none";
      };
    }

    // HUD wiring
    const elRoom = document.getElementById("room");
    const elPeers = document.getElementById("peers");
    const elMe = document.getElementById("me");
    const elHp = document.getElementById("hp");
    const elSt = document.getElementById("stam");
    const elHu = document.getElementById("hunger");
    const elWt = document.getElementById("wt");
    const elCap = document.getElementById("cap");

    const elWood = document.getElementById("wood");
    const elStone = document.getElementById("stone");
    const elOre = document.getElementById("ore");
    const elFiber = document.getElementById("fiber");
    const elHide = document.getElementById("hide");
    const elShard = document.getElementById("shard");
    const elBerry = document.getElementById("berry");

    document.getElementById("btnQuests").onclick = openQuests;
    document.getElementById("btnSkills").onclick = openSkills;
    document.getElementById("btnCraft").onclick = ()=> openCraft();
    document.getElementById("btnWorld").onclick = openWorld;
    document.getElementById("btnCredits").onclick = openCredits;

    document.getElementById("btnAction").onclick = doAction;
    document.getElementById("btnAttack").onclick = doAttack;

    document.getElementById("btnExport").onclick = () => {
      const payload = { v:1, room: roomId, ledger: ledger.raw };
      const blob = new Blob([JSON.stringify(payload, null, 2)], { type:"application/json" });
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = `shardwalk-${roomId}-ledger.json`;
      a.click();
      URL.revokeObjectURL(a.href);
    };

    document.getElementById("import").addEventListener("change", async (e)=>{
      const f = e.target.files?.[0];
      if (!f) return;
      try {
        const txt = await f.text();
        const payload = JSON.parse(txt);
        if (!payload?.ledger?.authors) throw new Error("bad");

        for (const [pub, arr] of Object.entries(payload.ledger.authors)){
          if (!Array.isArray(arr)) continue;
          if (!ledger.raw.authors[pub]) ledger.raw.authors[pub] = [];
          const have = new Set(ledger.raw.authors[pub].map(x=>x.id));
          for (const ev of arr){
            if (!ev?.id || have.has(ev.id)) continue;
            ledger.raw.authors[pub].push(ev);
            have.add(ev.id);
          }
        }

        rebuildLedgerIndexes();
        saveLedgerRaw(ledger.raw);
        repaintVisible();
        toast(t("toast.importOk"));
      } catch {
        toast(t("toast.importFail"));
      } finally {
        e.target.value = "";
      }
    });

    function refreshHud(){
      if (!local) return;
      elRoom.textContent = roomId;
      elPeers.textContent = String(net.peerCount || 0);
      elMe.textContent = `${me.name} (${me.pub ? me.pub.slice(0,8) : "‚Ä¶"})`;

      elHp.textContent = String(Math.round(local.stats.hp));
      elSt.textContent = String(Math.round(local.stats.stamina));
      elHu.textContent = String(Math.round(local.stats.hunger));

      const wt = Math.round(calcWeight(local.mats)*10)/10;
      const cap = calcCapacity();
      elWt.textContent = String(wt);
      elCap.textContent = String(cap);

      elWood.textContent = String(local.mats.wood|0);
      elStone.textContent = String(local.mats.stone|0);
      elOre.textContent = String(local.mats.ore|0);
      elFiber.textContent = String(local.mats.fiber|0);
      elHide.textContent = String(local.mats.hide|0);
      elShard.textContent = String(local.mats.shard|0);
      elBerry.textContent = String(local.mats.berry|0);

      document.getElementById("btnAction").textContent = mining.active ? t("toast.mining") : t("btn.action");
      document.getElementById("btnAttack").textContent = t("btn.attack");
    }

    function setupNetworking(){
      try {
        room = joinRoom({ appId: APP_ID, relayUrls, relayRedundancy: 2 }, roomId);
        net.enabled = true;

        [sendHello, getHello] = room.makeAction("hello");
        [sendMove,  getMove ] = room.makeAction("move");
        [sendEv,    getEv   ] = room.makeAction("ev");
        [sendGet,   getGet  ] = room.makeAction("get");
        [sendBatch, getBatch] = room.makeAction("batch");
        [sendSay,   getSay  ] = room.makeAction("say");

        room.onPeerJoin((peerId)=>{
          sendHello({ pub: me.pub, name: me.name, life: me.lifestyle, heads: headsSummary() }, peerId);
          net.peerCount++;
          refreshHud();
        });

        room.onPeerLeave(()=> {
          net.peerCount = Math.max(0, net.peerCount - 1);
          refreshHud();
        });

        getHello((msg, peerId)=>{
          if (!msg?.pub) return;
          ensureRemote(msg.pub, msg.name, msg.life);

          const theirHeads = msg.heads || {};
          for (const [pub, seq] of Object.entries(theirHeads)){
            const st = getAuthorState(pub);
            if ((st.seq|0) < (seq|0)){
              sendGet({ author: pub, fromSeq: st.seq + 1, limit: 250 }, peerId);
            }
          }
          sendHello({ pub: me.pub, name: me.name, life: me.lifestyle, heads: headsSummary() }, peerId);
        });

        getGet((req, peerId)=>{
          const author = req?.author;
          const fromSeq = req?.fromSeq|0;
          const limit = clamp(req?.limit|0 || 200, 1, 400);
          if (!author) return;

          const st = getAuthorState(author);
          const slice = st.events.filter(e => (e.seq|0) >= fromSeq).slice(0, limit);
          if (slice.length) sendBatch({ author, events: slice }, peerId);
        });

        getBatch((msg)=>{
          const author = msg?.author;
          const arr = msg?.events;
          if (!author || !Array.isArray(arr)) return;

          arr.sort((a,b)=> (a.seq-b.seq));
          let any = false;
          for (const ev of arr){
            const v = verifyEventBasic(ev);
            if (!v.ok) continue;
            const st = getAuthorState(ev.author);
            if (ev.seq === st.seq + 1 && (ev.prev||null) === (st.headId||null)){
              if (appendEventToLedger(ev)) any = true;
            }
          }

          if (any){
            saveLedgerDebounced();
            rebuildLedgerIndexes();
            repaintVisible();
            refreshHud();
          }
        });

        getEv((ev, peerId)=>{
          const v = verifyEventBasic(ev);
          if (!v.ok) return;

          const st = getAuthorState(ev.author);
          if (ev.seq === st.seq + 1 && (ev.prev||null) === (st.headId||null)){
            if (appendEventToLedger(ev)){
              saveLedgerDebounced();
              rebuildLedgerIndexes();
              repaintVisible();
              refreshHud();
            }
          } else {
            sendGet({ author: ev.author, fromSeq: st.seq + 1, limit: 250 }, peerId);
          }
        });

        getMove((m)=>{
          if (!m?.pub) return;
          ensureRemote(m.pub, m.name, m.life);
          const rp = remotePlayers.get(m.pub);
          rp.x = m.x|0; rp.y = m.y|0;
        });

        getSay((m)=>{
          if (!m?.pub || !m?.text) return;
          ensureRemote(m.pub, m.name, m.life);
          bubbleSay(m.pub, String(m.text).slice(0,60));
        });

      } catch {
        net.enabled = false;
        toast(t("toast.p2pOffline"));
      }
    }

    function ensureRemote(pub, name, life){
      if (!pub || pub === me.pub) return;
      if (!remotePlayers.has(pub)){
        let sprite = null;
        if (gameScene) sprite = gameScene.add.sprite(0,0,"p_other").setOrigin(0.5,1);
        remotePlayers.set(pub, { x:0, y:0, sprite, name: name||pub.slice(0,8), life: life||"?", bubble:null });
      } else {
        const rp = remotePlayers.get(pub);
        rp.name = name || rp.name;
        rp.life = life || rp.life;
        if (!rp.sprite && gameScene) rp.sprite = gameScene.add.sprite(0,0,"p_other").setOrigin(0.5,1);
      }
    }

    function bubbleSay(pub, text){
      const rp = remotePlayers.get(pub);
      if (!rp || !gameScene) return;

      if (rp.bubble) rp.bubble.destroy();
      rp.bubble = gameScene.add.text(0,0,text,{
        fontFamily:"system-ui, -apple-system, Segoe UI, Roboto, Arial",
        fontSize:"12px",
        color:"#fff",
        backgroundColor:"rgba(0,0,0,.45)",
        padding:{x:8,y:4}
      }).setOrigin(0.5,1);

      setTimeout(()=>{
        if (rp.bubble){
          rp.bubble.destroy();
          rp.bubble = null;
        }
      }, 1400);
    }

    // Start flow
    document.getElementById("start").onclick = async ()=>{
      const name = (nameEl.value || "").trim().slice(0,18);
      const pass = passEl.value || "";
      const lifestyle = lifeEl.value;

      if (!name) return toast(t("toast.chooseName"));
      if (!pass) return toast(t("toast.choosePass"));

      const seed = sha256(te.encode(`key:${roomId}:${name}:${pass}`)).slice(0,32);
      const kp = nacl.sign.keyPair.fromSeed(seed);

      me.name = name;
      me.lifestyle = lifestyle;
      me.pub = toBase64(kp.publicKey);
      me.secretKey = kp.secretKey;

      localStorage.setItem(`sw_${roomId}_name`, name);
      localStorage.setItem(`sw_${roomId}_life`, lifestyle);

      local = loadLocal(me.pub) || defaultLocalState();

      const start = LIFESTYLES[lifestyle]?.start || {};
      if (!local._kit){
        for (const [k,v] of Object.entries(start)){
          if (local.mats[k] != null) local.mats[k] += v|0;
        }
        local._kit = true;
      }

      if (!local.quests.active || !local.quests.active.length){
        generateQuests();
      }

      const profileKnown = (ledger.raw.authors[me.pub]?.length || 0) > 0;
      if (!profileKnown){
        const ev = await createSignedEvent("PROFILE", { name: me.name, lifestyle: me.lifestyle });
        if (verifyEventBasic(ev).ok){
          appendEventToLedger(ev);
          saveLedgerDebounced();
          rebuildLedgerIndexes();
        }
      }

      loginEl.style.display = "none";
      document.getElementById("hud").style.display = "";
      document.getElementById("pad").style.display = "";
      document.getElementById("actions").style.display = "";

      setupNetworking();

      new Phaser.Game({
        type: Phaser.AUTO,
        parent: "game",
        backgroundColor: "#0e0e10",
        pixelArt: true,
        antialias: false,
        scale: { mode: Phaser.Scale.RESIZE, autoCenter: Phaser.Scale.CENTER_BOTH },
        scene: [Main]
      });

      if (net.enabled){
        sendMove({ pub: me.pub, x: local.player.x|0, y: local.player.y|0, name: me.name, life: me.lifestyle });
        sendHello({ pub: me.pub, name: me.name, life: me.lifestyle, heads: headsSummary() });
      }

      centerTile.x = Math.round(local.player.x);
      centerTile.y = Math.round(local.player.y);

      toast(t("toast.welcome"));
      refreshHud();
    };

    // Chat (ephemeral)
    window.addEventListener("keydown", (e)=>{
      if (e.key === "Enter" && document.getElementById("hud").style.display !== "none"){
        const msg = prompt(t("prompt.chat"), t("prompt.chatDefault"));
        if (!msg) return;
        if (net.enabled) sendSay({ pub: me.pub, name: me.name, life: me.lifestyle, text: msg });
        toast(t("toast.msgSent"));
      }
    });

    // Login picker render + initial apply
    renderLangPicker("langPickerLogin");
    setLanguage(currentLang);

    // Default life selection after i18n build
    lifeEl.value = lastLife;

    // HUD flag
    document.getElementById("langIcon").src = FLAG[currentLang];
  </script>
</body>
</html>
